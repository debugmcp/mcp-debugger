# packages/adapter-rust/vendor/codelldb/linux-x64/lldb/lib/python3.12/site-packages/pip/_vendor/tenacity/stop.py
@source-hash: 60c26ced98197cd0
@generated: 2026-02-09T18:01:51Z

## Purpose

Defines stop condition strategies for the Tenacity retry library. Contains abstract base classes and concrete implementations that determine when retry attempts should cease based on various criteria (attempts, time, events).

## Key Components

### Abstract Base Class
- **`stop_base` (L27-38)**: Abstract base class defining the stop strategy interface
  - `__call__(retry_state)`: Abstract method that returns bool indicating whether to stop retrying
  - `__and__`, `__or__`: Operators for combining stop conditions using logical AND/OR

### Composite Stop Strategies
- **`stop_any` (L44-51)**: Stops if ANY of the provided stop conditions are met
  - Uses `any()` to evaluate multiple stop conditions in parallel
- **`stop_all` (L54-61)**: Stops only if ALL provided stop conditions are met
  - Uses `all()` to require satisfaction of every condition

### Concrete Stop Implementations
- **`_stop_never` (L64-68)**: Never stops retrying (always returns False)
  - Singleton instance available as `stop_never` (L71)
- **`stop_when_event_set` (L74-81)**: Stops when a threading.Event is set
  - Useful for external cancellation via threading primitives
- **`stop_after_attempt` (L84-91)**: Stops after a maximum number of attempts
  - Compares `retry_state.attempt_number >= max_attempt_number`
- **`stop_after_delay` (L94-103)**: Stops after a maximum elapsed time
  - Converts time units via `_utils.to_seconds()` and compares against `retry_state.seconds_since_start`

## Key Dependencies
- `_utils`: For time unit conversion utilities
- `RetryCallState`: Core state object passed to all stop strategies (TYPE_CHECKING import)
- `threading.Event`: For event-based stopping (TYPE_CHECKING import)

## Type Definitions
- **`StopBaseT` (L41)**: Union type accepting either `stop_base` instances or callable functions

## Architecture Notes
- Strategy pattern implementation with composable stop conditions
- Operator overloading enables intuitive combination syntax: `stop1 & stop2`, `stop1 | stop2`
- All concrete strategies follow the same callable interface pattern
- Time-based stopping includes runtime validation to ensure proper state setup