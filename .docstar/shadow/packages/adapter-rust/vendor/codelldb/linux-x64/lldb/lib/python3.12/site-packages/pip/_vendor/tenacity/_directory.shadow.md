# packages/adapter-rust/vendor/codelldb/linux-x64/lldb/lib/python3.12/site-packages/pip/_vendor/tenacity/
@generated: 2026-02-09T18:16:18Z

## Overall Purpose
This directory contains the complete implementation of the **Tenacity** retry library - a sophisticated, strategy-based retry system that provides flexible and configurable retry functionality for Python applications. The library supports both synchronous and asynchronous execution environments with pluggable strategies for retry conditions, backoff timing, stopping criteria, and callback hooks.

## Architecture Pattern
Tenacity implements a **comprehensive strategy pattern** where retry behavior is composed from independent, interchangeable strategy objects:

- **Retry Strategies** (`retry.py`): Define when to retry based on exceptions or return values
- **Wait Strategies** (`wait.py`): Control timing and backoff between attempts  
- **Stop Strategies** (`stop.py`): Determine when to cease retry attempts
- **Before/After Callbacks** (`before.py`, `after.py`, `before_sleep.py`): Execute side effects around retry attempts
- **Sleep Mechanisms** (`nap.py`): Provide different sleep implementations including interruptible delays

## Key Components and Integration

### Core Retry Engine (`__init__.py`)
- **`BaseRetrying`**: Abstract orchestrator managing the retry loop via pluggable strategies
- **`Retrying`**: Synchronous implementation for regular functions
- **`RetryCallState`**: Tracks attempt state, timing, and outcomes across retries
- **`AttemptManager`**: Context manager for individual retry attempts with exception handling
- **`@retry` decorator**: Main public API that auto-detects sync vs async functions

### Async Support (`_asyncio.py`)
- **`AsyncRetrying`**: Async/await compatible retry orchestrator extending `BaseRetrying`
- Seamless integration with `asyncio.sleep()` and coroutine functions
- Maintains API compatibility with synchronous version

### Framework Adapters
- **`tornadoweb.py`**: Tornado web framework integration using generator-based coroutines
- **Tornado integration disabled** in main module to prevent pip compatibility issues

## Public API Surface

### Primary Entry Points
1. **`@retry` decorator**: Auto-configuring decorator supporting both sync and async functions
2. **`Retrying()` class**: Direct instantiation for programmatic retry control  
3. **`AsyncRetrying()` class**: Async-specific retry orchestrator
4. **Strategy classes**: All retry, wait, stop, and callback strategies are public

### Configuration Interface
```python
@retry(
    retry=retry_if_exception_type(ConnectionError),
    wait=wait_exponential(multiplier=1, min=4, max=10),
    stop=stop_after_attempt(5),
    before=before_log(logger, logging.INFO),
    after=after_log(logger, logging.INFO)
)
```

## Internal Organization and Data Flow

### Retry Loop Flow
1. **Initialization**: Create `RetryCallState` with attempt tracking
2. **Strategy Evaluation**: `BaseRetrying.iter()` consults strategies to determine next action:
   - `DoAttempt`: Execute the wrapped function
   - `DoSleep`: Wait specified duration before next attempt  
   - Return value: Terminate with result
3. **State Management**: Update attempt count, timing, and outcome data
4. **Callback Execution**: Trigger before/after hooks at appropriate points

### Exception and Result Handling
- **`Future` class**: Wraps attempt results/exceptions with metadata
- **Exception preservation**: Full traceback and cause chain maintained
- **`TryAgain` exception**: Forces immediate retry when raised
- **`RetryError`**: Raised when all attempts exhausted

### Thread Safety and Statistics
- **Thread-local storage**: Per-thread statistics via `threading.local`
- **Monotonic timing**: Accurate elapsed time tracking using `time.monotonic()`
- **Statistics reset**: Automatic cleanup between retry operations

## Important Patterns and Conventions

### Strategy Composition
- **Additive composition**: Wait strategies can be combined with `+` operator
- **Logical composition**: Retry/stop strategies support `&` (AND) and `|` (OR) operators
- **Strategy factories**: Many strategies are factory functions returning configured callables

### Error Handling
- **Defensive validation**: Strategies validate `RetryCallState` consistency before execution
- **Graceful degradation**: Missing optional data handled with sensible defaults
- **Exception chain traversal**: Recursive cause checking for nested exception analysis

### Utility Integration (`_utils.py`)
- **Time normalization**: Unified handling of int/float/timedelta inputs
- **Ordinal formatting**: Human-readable attempt numbering ("1st attempt", "2nd attempt")
- **Callback introspection**: Automatic function name extraction for logging
- **Constants**: Shared limits like `MAX_WAIT` for preventing overflow

## Dependencies and Integration
- **Minimal external dependencies**: Uses only Python standard library
- **Framework adapters**: Optional integration with asyncio and Tornado
- **Vendor context**: Part of pip's vendored dependencies for isolated execution
- **Type safety**: Comprehensive type hints with forward references to prevent circular imports

This directory represents a complete, production-ready retry library with sophisticated strategy composition, comprehensive async support, and extensive configurability while maintaining a clean, intuitive public API.