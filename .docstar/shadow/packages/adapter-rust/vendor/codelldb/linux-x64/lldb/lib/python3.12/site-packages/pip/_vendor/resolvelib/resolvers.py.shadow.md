# packages/adapter-rust/vendor/codelldb/linux-x64/lldb/lib/python3.12/site-packages/pip/_vendor/resolvelib/resolvers.py
@source-hash: 1bcaec2d94aaeb88
@generated: 2026-02-09T18:01:46Z

## Purpose
Core resolver implementation for dependency resolution using backtracking algorithm. Provides constraint satisfaction for package dependencies with conflict detection and resolution.

## Key Components

### Data Structures
- `RequirementInformation` (L8-10): Named tuple linking requirement to its parent candidate
- `State` (L102): Named tuple representing resolution state with mapping, criteria, and backtrack causes
- `Result` (L479): Named tuple containing final resolution with mapping, dependency graph, and criteria

### Exception Hierarchy
- `ResolverException` (L13-18): Base exception for all resolver errors
- `RequirementsConflicted` (L21-29): Raised when requirements cannot coexist
- `InconsistentCandidate` (L32-42): Raised when candidate doesn't satisfy criterion
- `ResolutionError` (L84-85): Base for resolution failures
- `ResolutionImpossible` (L88-92): No valid resolution exists
- `ResolutionTooDeep` (L95-98): Maximum rounds exceeded

### Core Classes

#### Criterion (L45-82)
Represents possible resolution results for a package. Contains:
- `candidates`: Available candidates satisfying requirements
- `information`: Collection of RequirementInformation pairs
- `incompatibilities`: Known incompatible candidates
- Key methods: `iter_requirement()` (L77), `iter_parent()` (L80)

#### Resolution (L105-457)
Stateful resolution engine managing backtracking algorithm:
- `__init__` (L112-115): Initialize with provider and reporter
- `state` property (L117-122): Access current resolution state
- `_push_new_state()` (L124-136): Create new state for next resolution round
- `_add_to_criteria()` (L138-175): Add requirement to criteria, find matches
- `_remove_information_from_criteria()` (L177-200): Clean up parent information
- `_get_preference()` (L202-215): Get provider preference for criterion selection
- `_is_current_pin_satisfying()` (L217-225): Check if current pin satisfies criterion
- `_get_updated_criteria()` (L227-231): Update criteria with candidate dependencies
- `_attempt_to_pin_criterion()` (L233-268): Try to pin a criterion, handle conflicts
- `_backjump()` (L270-379): Backtracking implementation with incompatibility propagation
- `resolve()` (L381-457): Main resolution algorithm with round-based iteration

#### Resolver (L512-547)
Public interface extending AbstractResolver:
- `resolve()` (L517-546): Entry point taking requirements and max_rounds, returns Result

### Key Algorithms

**Resolution Process (L381-457)**:
1. Initialize root state with requirements
2. Iteratively select unsatisfied criteria by preference
3. Attempt to pin candidates, handling conflicts
4. Backtrack on failure, propagate incompatibilities
5. Continue until all criteria satisfied or impossible

**Backtracking (L270-379)**:
Complex backjumping algorithm that:
1. Identifies incompatible dependencies causing conflict
2. Backtracks to relevant state that contributed to incompatibility
3. Applies learned incompatibilities to previous state
4. Creates new state with additional constraints

### Utility Functions
- `_has_route_to_root()` (L460-476): Recursive connectivity check in dependency graph
- `_build_result()` (L482-509): Construct final Result with pruned mapping and dependency graph

## Dependencies
- `.providers.AbstractResolver`: Base resolver interface
- `.structs`: DirectedGraph, IteratorMapping, build_iter_view utilities
- Standard library: collections, itertools, operator

## Architecture Notes
- Immutable Criterion design for safe state management
- Provider pattern for pluggable resolution strategies
- Reporter pattern for progress tracking and debugging
- Backtracking with constraint learning for efficiency
- State history maintained for complex backjumping scenarios