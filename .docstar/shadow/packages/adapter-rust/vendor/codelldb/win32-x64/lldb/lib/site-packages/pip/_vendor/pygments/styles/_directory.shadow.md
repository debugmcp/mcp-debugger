# packages/adapter-rust/vendor/codelldb/win32-x64/lldb/lib/site-packages/pip/_vendor/pygments/styles/
@generated: 2026-02-09T18:16:12Z

## Purpose and Responsibility

This directory implements Pygments' style system infrastructure - the core registry and loading mechanism for syntax highlighting styles. It provides a centralized, extensible architecture for discovering, loading, and managing visual themes used by the Pygments syntax highlighting library.

## Key Components and Integration

### Core Architecture
- **`__init__.py`**: Main public API and style factory with multi-tier loading strategy
- **`_mapping.py`**: Auto-generated registry containing mappings for 48 built-in styles

### Component Relationships
The system operates through a two-layer architecture:

1. **Registry Layer** (`_mapping.py`):
   - `STYLES` dictionary maps style class names to (module_path, identifier, tuple) entries
   - Auto-generated from `scripts/gen_mapfiles.py` ensuring consistency
   - Supports 48 built-in styles including popular themes (Monokai, Dracula, Visual Studio, Solarized variants)

2. **Factory Layer** (`__init__.py`):
   - `get_style_by_name()` implements three-tier resolution strategy:
     - Primary: Built-in styles from `STYLES` registry
     - Secondary: Plugin-discovered styles via external system
     - Fallback: Package-local module discovery
   - `get_all_styles()` aggregates styles from all sources

## Public API Surface

### Primary Entry Points
- **`get_style_by_name(name)`**: Main factory function for style class resolution
  - Input: Style name (string)
  - Returns: Style class object
  - Raises: `ClassNotFound` for invalid styles
- **`get_all_styles()`**: Generator yielding all available style names
- **`STYLE_MAP`**: Legacy dictionary (deprecated, use `STYLES` from `_mapping`)

### Style Resolution Process
1. Check built-in `STYLES` registry for exact matches
2. Query plugin system for externally-provided styles  
3. Attempt fallback loading from local modules
4. Raise descriptive error if all resolution paths fail

## Internal Organization and Data Flow

### Style Loading Pipeline
```
User Request → get_style_by_name() → Registry Lookup → Dynamic Import → Style Class
                     ↓
            Plugin Discovery (if registry miss)
                     ↓  
            Fallback Module Loading (if plugin miss)
```

### Performance Optimizations
- `_STYLE_NAME_TO_MODULE_MAP`: Internal reverse lookup cache for performance
- Lazy loading: Styles imported only when requested
- Plugin discovery integrated without affecting built-in style performance

## Important Patterns and Conventions

### Architectural Patterns
- **Registry Pattern**: Centralized style discovery via `STYLES` mapping
- **Factory Pattern**: `get_style_by_name()` abstracts style instantiation
- **Plugin Architecture**: Extensible system supporting external style providers
- **Auto-generation Workflow**: Registry maintained via tooling, not manual editing

### Naming Conventions
- Built-in styles: `{name}::ClassName` format in registry
- Fallback styles: `{TitleCase}Style` class name pattern
- Style identifiers: kebab-case for external reference (e.g., 'one-dark')
- Module paths: `pygments.styles.{module_name}` pattern

### Critical Constraints
- Style names must be globally unique across built-in and plugin sources
- `_mapping.py` is auto-generated and must not be manually edited
- Dynamic imports may fail gracefully with appropriate error handling
- Plugin system integration maintains backward compatibility with built-in styles