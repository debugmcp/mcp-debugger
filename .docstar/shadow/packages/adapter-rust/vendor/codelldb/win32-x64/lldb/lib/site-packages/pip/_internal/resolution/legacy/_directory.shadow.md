# packages/adapter-rust/vendor/codelldb/win32-x64/lldb/lib/site-packages/pip/_internal/resolution/legacy/
@generated: 2026-02-09T18:16:09Z

## Legacy Dependency Resolution Module

This directory implements pip's original dependency resolution algorithm, serving as a fallback system for scenarios where the newer resolver cannot be used or for maintaining backward compatibility.

### Overall Purpose and Responsibility

The legacy resolver module provides a "first found, wins" breadth-first dependency resolution strategy. It handles the complex task of determining which package versions to install while managing conflicts, constraints, upgrade scenarios, and Python version compatibility. This resolver was pip's primary dependency resolution engine before the introduction of the newer backtracking resolver.

### Key Components and Architecture

**Resolver Class** - The central orchestrator that implements the BaseResolver interface:
- Manages resolution state including preparer, finder, wheel cache, and dependency tracking
- Supports multiple upgrade strategies: "eager", "only-if-needed", "to-satisfy-only"
- Coordinates between requirement discovery, validation, and preparation phases

**Resolution Algorithm**:
- Top-level requirements follow "only one spec per project" rule, overriding sub-dependencies
- Sub-dependencies resolved via breadth-first traversal with "first found, wins" policy
- Uses DiscoveredDependencies mapping to track parent-child requirement relationships

**Python Compatibility Validation** - Validates distribution compatibility against Python version requirements with graceful error handling for invalid specifiers.

**Installation Ordering** - Generates topological installation order ensuring dependencies are installed before their dependents, with cycle detection and handling.

### Public API Surface

**Primary Entry Point**:
- `Resolver.resolve()` - Main resolution method returning a RequirementSet of all resolved requirements

**Key Configuration**:
- Upgrade strategy selection (eager/only-if-needed/to-satisfy-only)
- Force reinstall and ignore installed package options
- Hash validation and wheel cache integration

### Internal Organization and Data Flow

1. **Requirement Processing** - `_add_requirement_to_set()` handles marker evaluation, conflict detection, and constraint logic
2. **Installation Decision** - `_check_skip_installed()` determines upgrade/reinstall necessity based on strategy flags
3. **Distribution Preparation** - `_get_dist_for()` coordinates package preparation with user notifications
4. **Dependency Discovery** - `_resolve_one()` processes individual requirements and recursively discovers sub-dependencies
5. **Link Association** - `_populate_link()` ensures requirements have download links, integrating with wheel cache

### Important Patterns and Conventions

- **Breadth-First Resolution**: Processes all requirements at the current level before diving deeper
- **State Tracking**: Uses `_discovered_dependencies` to maintain parent-child relationships and avoid cycles
- **Graceful Degradation**: Handles invalid metadata and compatibility issues with warnings rather than hard failures
- **Cache Integration**: Leverages wheel cache for performance while respecting hash validation requirements
- **Separation of Concerns**: Resolution logic separated from package preparation and download operations

### Integration Points

The module integrates tightly with pip's internal systems:
- RequirementPreparer for package preparation and download
- PackageFinder for version discovery and link resolution  
- WheelCache for performance optimization
- Various pip utilities for compatibility checking, logging, and metadata handling

This legacy resolver serves as a critical fallback mechanism and provides insight into pip's dependency resolution evolution, maintaining the simpler but less optimal "first found, wins" approach for compatibility scenarios.