# packages/adapter-rust/vendor/codelldb/darwin-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/msgpack/
@generated: 2026-02-09T18:16:14Z

## Purpose and Responsibility

This directory contains the complete msgpack library implementation - a high-performance MessagePack serialization/deserialization library with automatic fallback capabilities. MessagePack is a binary serialization format that provides faster and more compact data encoding than JSON while maintaining cross-language compatibility.

## Architecture and Components

### Dual Implementation Strategy
The library employs a sophisticated fallback architecture managed through `__init__.py`:
- **Primary**: Optimized C extension (`_cmsgpack`) for maximum performance
- **Fallback**: Pure Python implementation (`fallback.py`) ensuring universal compatibility
- **Selection**: Environment-controlled via `MSGPACK_PUREPYTHON` or automatic fallback on ImportError

### Core Components

**Main API Module (`__init__.py`)**
- Unified facade providing consistent interface across implementations
- Core functions: `pack()`, `packb()`, `unpack()`, `unpackb()`
- Compatibility aliases matching JSON/pickle APIs: `load/loads`, `dump/dumps`
- Version management and implementation selection logic

**Pure Python Implementation (`fallback.py`)**
- Complete MessagePack protocol implementation when C extensions unavailable
- `Unpacker` class: Streaming deserializer with buffer management and extensive configuration
- `Packer` class: Recursive serializer with type-specific encoding logic
- Platform optimizations (PyPy StringBuilder integration)
- Format parsing via `_MSGPACK_HEADERS` lookup table

**Extension Types (`ext.py`)**
- `ExtType`: General-purpose extension type container (code 0-127 + data)
- `Timestamp`: Official msgpack timestamp extension type (-1) with nanosecond precision
- Format-aware serialization with variable-length encoding optimization
- Integration with Python datetime objects and Unix timestamps

**Exception Hierarchy (`exceptions.py`)**
- Specialized error types: `UnpackException`, `BufferFull`, `OutOfData`, `FormatError`, `StackError`
- `ExtraData`: Handles trailing data in one-shot unpacking scenarios
- Backward compatibility aliases for deprecated exception types

## Public API Surface

### Primary Entry Points
- `pack(obj, stream, **kwargs)`: Serialize object to stream
- `packb(obj, **kwargs)`: Serialize object to bytes
- `unpack(stream, **kwargs)`: Deserialize from stream  
- `unpackb(data, **kwargs)`: Deserialize from bytes
- `Packer`, `Unpacker`: Direct class access for advanced usage

### Extension Types
- `ExtType(code, data)`: Custom extension type creation
- `Timestamp`: High-precision timestamp handling with datetime integration

### Configuration Options
- Type handling: `raw`, `use_list`, `strict_map_key`, `strict_types`
- Performance: `use_single_float`, `autoreset`, buffer size limits
- Extensibility: `object_hook`, `default` handlers for custom types
- Streaming: File-like object support with incremental processing

## Data Flow and Patterns

### Serialization Flow
1. `pack/packb` → `Packer` instance → recursive `_pack()` → type-specific encoders
2. Extension types handled via `pack_ext_type()` with `ExtType`/`Timestamp` support
3. Buffer management with automatic reset and size limiting

### Deserialization Flow  
1. `unpack/unpackb` → `Unpacker` instance → `_unpack()` → header parsing → recursive reconstruction
2. Stream-based processing with `feed()` for incremental data
3. Configurable type conversion and custom hooks at each level

### Error Handling Strategy
- Hierarchical exceptions with base classes for broad catching
- Specific error types for different failure modes (format, buffer, data availability)
- Graceful degradation with implementation fallbacks

## Important Patterns

- **Performance First**: C extension preferred with pure Python safety net
- **Streaming Support**: Both one-shot and incremental processing modes
- **Type Safety**: Configurable strict typing with validation hooks  
- **Memory Efficiency**: Slot-based classes, buffer reuse, format optimization
- **Compatibility**: Multiple API styles (JSON-like, pickle-like) for easy adoption
- **Extension Friendly**: Built-in support for custom types via extension mechanism