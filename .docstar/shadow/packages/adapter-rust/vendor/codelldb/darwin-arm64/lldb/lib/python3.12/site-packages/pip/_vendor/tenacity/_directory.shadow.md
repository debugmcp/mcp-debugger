# packages/adapter-rust/vendor/codelldb/darwin-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/tenacity/
@generated: 2026-02-09T18:16:17Z

## Purpose and Responsibility
This directory contains the complete tenacity library - a comprehensive Python retry framework that provides declarative, composable retry logic for functions with configurable strategies for when to retry, how long to wait between attempts, and when to stop. The library supports both synchronous and asynchronous execution patterns with pluggable strategy components.

## Core Architecture

### Main Entry Points
- **`__init__.py`**: Primary public API providing the `retry()` decorator and `Retrying`/`AsyncRetrying` classes
- **`_asyncio.py`**: Async/await support via `AsyncRetrying` class for coroutines 
- **`tornadoweb.py`**: Tornado web framework integration with `TornadoRetrying` class

### Strategy Framework
The library implements a strategy pattern across four key dimensions:

**Retry Conditions (`retry.py`)**:
- `retry_if_exception_type()`: Retry on specific exceptions
- `retry_if_result()`: Retry based on return values
- `retry_if_exception_message()`: Retry on exception message patterns
- Composition via `retry_any()`/`retry_all()` for complex logic

**Wait Strategies (`wait.py`)**:
- `wait_fixed()`: Constant delays
- `wait_exponential()`: Exponential backoff with jitter options
- `wait_random()`: Random delays within bounds
- `wait_chain()`/`wait_combine()`: Sequential or additive combinations

**Stop Conditions (`stop.py`)**:
- `stop_after_attempt()`: Maximum retry count limits
- `stop_after_delay()`: Total time-based limits
- `stop_when_event_set()`: External cancellation signals
- Logical composition via `stop_any()`/`stop_all()`

**Lifecycle Hooks**:
- `before.py`: Pre-attempt callbacks (logging, metrics)
- `after.py`: Post-attempt callbacks (cleanup, reporting)  
- `before_sleep.py`: Pre-delay callbacks (progress indication)
- `nap.py`: Sleep implementations (time-based, event-based)

### Core State Management
- **`RetryCallState`**: Central state object tracking attempt count, timing, outcomes, and function context across retry operations
- **`AttemptManager`**: Context manager for individual retry attempts with exception capture
- **`Future`**: Wrapper tracking attempt metadata and success/failure status

### Control Flow
- **`BaseRetrying`**: Abstract retry controller implementing core retry logic and state machine
- **`TryAgain`**: Exception to explicitly trigger retries
- **`RetryError`**: Exception raised when retry limits exceeded
- **Action classes** (`DoAttempt`, `DoSleep`): Control flow markers for retry state machine

## Public API Surface

### Decorator Interface
```python
@retry(stop=stop_after_attempt(3), 
       wait=wait_exponential(multiplier=1, max=10),
       retry=retry_if_exception_type(ConnectionError))
def my_function():
    # Function with retry logic
```

### Class Interface  
```python
retrying = Retrying(stop=..., wait=..., retry=...)
result = retrying(my_function, *args, **kwargs)

# Async version
async_retrying = AsyncRetrying(...)
result = await async_retrying(my_async_function, *args, **kwargs)
```

### Manual Control
```python
for attempt in Retrying(...):
    with attempt:
        # Custom retry logic
```

## Internal Organization and Data Flow

1. **Strategy Selection**: User configures retry/wait/stop strategies via decorator or class parameters
2. **State Initialization**: `RetryCallState` created to track retry session metadata
3. **Retry Loop**: `BaseRetrying.iter()` implements state machine:
   - Evaluates stop conditions first
   - On continue: returns `DoAttempt` action
   - On function failure: evaluates retry conditions
   - On retry: calculates wait time and returns `DoSleep` action
   - On stop: returns final result or raises `RetryError`
4. **Execution**: Concrete retry classes (`Retrying`, `AsyncRetrying`, `TornadoRetrying`) handle function execution and sleep operations

## Key Patterns and Conventions

- **Composability**: All strategies support logical combination via operators (`&`, `|`) and composition classes
- **Type Safety**: Comprehensive type hints with generic support for wrapped function signatures
- **Pluggable Architecture**: Consistent interfaces allow custom strategy implementations
- **Context Preservation**: Exception info and function metadata preserved throughout retry cycles
- **Thread Safety**: Thread-local statistics tracking and proper state isolation
- **Async Compatibility**: First-class support for async/await, Tornado, and synchronous patterns
- **Defensive Programming**: Validation, overflow protection, and graceful fallbacks throughout

## Integration Context
This tenacity installation is vendored within pip at `pip/_vendor/tenacity`, indicating it's used internally by pip for retry logic around package operations, network requests, or other failure-prone operations where robust retry behavior is needed.