# packages/adapter-rust/vendor/codelldb/darwin-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/cachecontrol/cache.py
@source-hash: 393423ef6b547fc0
@generated: 2026-02-09T17:58:44Z

## Primary Purpose
Defines the cache object API for cachecontrol library, providing abstract base classes and a concrete thread-safe in-memory implementation for HTTP response caching.

## Core Classes

### BaseCache (L18-32)
Abstract base class defining the standard cache interface:
- `get(key: str) -> bytes | None` (L19): Retrieve cached value by key
- `set(key: str, value: bytes, expires: int | datetime | None = None) -> None` (L22-25): Store value with optional expiration
- `delete(key: str) -> None` (L27): Remove cached entry
- `close() -> None` (L30): Cleanup method (no-op in base implementation)

### DictCache(BaseCache) (L34-52)
Thread-safe in-memory cache implementation using dictionary storage:
- `__init__(init_dict: MutableMapping[str, bytes] | None = None)` (L35): Initialize with optional pre-existing dictionary
- Uses `threading.Lock()` (L36) for thread safety during write operations
- `get()` (L39): Direct dictionary lookup without locking (read-only)
- `set()` (L42-46): Thread-safe write using lock context manager
- `delete()` (L48-51): Thread-safe removal with existence check

### SeparateBodyBaseCache(BaseCache) (L54-74)
Abstract base for caches that separate metadata from response body storage:
- Designed for use cases where body data needs separate handling
- `set_body(key: str, body: bytes) -> None` (L67): Store response body separately
- `get_body(key: str) -> IO[bytes] | None` (L70): Retrieve body as file-like object
- Expected pattern: `cache.set(key, metadata)` followed by `cache.set_body(key, body)`

## Key Dependencies
- `threading.Lock` for thread safety in DictCache
- `typing` annotations for type safety (MutableMapping, IO, TYPE_CHECKING)
- Conditional datetime import for type checking only

## Architectural Patterns
- Template method pattern: BaseCache defines interface, concrete classes implement behavior
- Separation of concerns: SeparateBodyBaseCache allows distinct handling of metadata vs body data
- Thread safety: DictCache protects shared state with locks on write operations but allows lock-free reads

## Critical Invariants
- DictCache read operations are not locked (assumes atomic dictionary reads in CPython)
- SeparateBodyBaseCache requires coordinated calls to `set()` and `set_body()` for complete caching
- Expires parameter in `set()` is accepted but not implemented in DictCache (silently ignored)