# packages/adapter-rust/vendor/codelldb/darwin-arm64/lldb/lib/python3.12/site-packages/pip/_internal/resolution/resolvelib/factory.py
@source-hash: ab334847f62c0b89
@generated: 2026-02-09T17:57:38Z

## Purpose
Factory class for pip's resolvelib-based dependency resolution system. Creates and manages candidates and requirements, providing the core interface between pip's internal structures and the resolvelib resolver.

## Core Classes

**Factory (L95-816)**: Main factory class that creates candidates and requirements for the resolver
- Constructor initializes caches, finder, preparer, and configuration flags
- Manages multiple candidate caches: `_link_candidate_cache`, `_editable_candidate_cache`, `_installed_candidate_cache`, `_extras_candidate_cache`
- Tracks build failures in `_build_failures` cache to avoid retrying failed builds

**CollectedRootRequirements (L89-93)**: NamedTuple containing processed root requirements
- `requirements`: List of resolved requirement objects
- `constraints`: Dict mapping package names to constraint objects
- `user_requested`: Dict tracking user-requested packages with ordering

## Key Methods

**find_candidates() (L390-464)**: Main entry point for candidate discovery
- Collects explicit candidates from requirements and constraints
- Falls back to index-based candidate finding via `_iter_found_candidates()`
- Filters candidates by incompatibility and constraint satisfaction

**_iter_found_candidates() (L249-344)**: Discovers candidates from package index
- Handles installed vs. index candidate preference
- Implements PEP 592 yanked release logic (L307-328)
- Returns FoundCandidates object with lazy candidate creation

**collect_root_requirements() (L519-559)**: Processes initial requirements into resolver format
- Separates constraints from regular requirements
- Handles requirement marker evaluation
- Sorts requirements to optimize resolver performance (extras last)

**_make_requirements_from_install_req() (L466-517)**: Converts InstallRequirement to Requirement objects
- Handles marker-based filtering
- Splits requirements with both constraints and extras into separate objects
- Creates unsatisfiable requirements for failed link candidates

## Candidate Creation

**_make_base_candidate_from_link() (L192-247)**: Creates base candidates from links
- Caches candidates to avoid duplicate creation
- Handles editable vs. regular link candidates
- Records build failures for later avoidance

**_make_candidate_from_dist() (L162-175)**: Creates candidates from installed distributions
- Uses canonical names for caching
- Wraps with extras if needed

**_make_extras_candidate() (L147-160)**: Creates candidates with extra dependencies
- Uses (base_id, extras) tuple as cache key
- Canonicalizes extra names for consistent caching

## Error Handling & Reporting

**get_installation_error() (L716-816)**: Converts ResolutionImpossible to InstallationError
- Prioritizes Python version conflicts
- Provides detailed conflict analysis for multiple causes
- Generates helpful error messages with resolution suggestions

**_report_requires_python_error() (L642-662)**: Specialized Python version conflict reporting
- Handles single vs. multiple Python version conflicts
- Formats version specifier information

**_report_single_requirement_conflict() (L664-714)**: Reports unresolvable single requirements
- Lists available versions (including yanked)
- Shows Python version compatibility issues
- Special handling for common "requirements.txt" mistake

## Dependencies
- **resolvelib**: External resolution library integration
- **PackageFinder**: Package discovery and version selection
- **RequirementPreparer**: Package preparation and building
- **WheelCache**: Wheel caching for performance
- **Candidate/Requirement**: Abstract base types from `.base`
- **Various candidate types**: From `.candidates` module
- **Requirement types**: From `.requirements` module

## Architecture Notes
- Heavy use of caching to avoid redundant candidate creation and build attempts
- Lazy candidate creation through functional interfaces
- Clear separation between explicit (user-specified) and discovered (index) candidates
- Constraint handling is centralized for optimization
- Build failure tracking prevents infinite retry loops