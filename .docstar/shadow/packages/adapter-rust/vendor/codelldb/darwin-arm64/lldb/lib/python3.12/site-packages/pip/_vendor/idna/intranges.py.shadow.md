# packages/adapter-rust/vendor/codelldb/darwin-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/idna/intranges.py
@source-hash: 601af87d162e587e
@generated: 2026-02-09T17:58:47Z

## Purpose
Efficiently represents sparse integer sets as compressed ranges and provides O(log n) membership testing. Optimized for cases where integers form long consecutive sequences.

## Core Functions

### intranges_from_list(list_: List[int]) -> Tuple[int, ...] (L11-30)
Converts a list of integers into a compressed range representation:
- Sorts input integers and identifies consecutive runs
- Encodes each range as single 64-bit integer using bit packing: `(start << 32) | end`
- Returns tuple of encoded ranges for efficient binary search
- Uses half-open intervals: `[start, end)` where `end = last_value + 1`

### intranges_contain(int_: int, ranges: Tuple[int, ...]) -> bool (L39-54)
Determines membership in O(log n) time using binary search:
- Creates probe value by encoding `(int_, 0)` 
- Uses `bisect.bisect_left` to find insertion point
- Checks both adjacent positions for potential containing ranges
- Handles edge cases where target equals range start or falls within range

### Range Encoding Utilities
- `_encode_range(start: int, end: int) -> int` (L32-33): Packs range into 64-bit integer
- `_decode_range(r: int) -> Tuple[int, int]` (L35-36): Unpacks range from integer

## Key Dependencies
- `bisect` module for binary search operations
- `typing` for type annotations

## Algorithm Details
- Range compression eliminates storage of individual consecutive integers
- Binary search on encoded ranges provides logarithmic lookup time
- Bit-packing enables efficient comparison and storage of range boundaries
- Half-open interval convention simplifies range logic

## Performance Characteristics
- Space: O(number of runs) instead of O(number of integers)
- Lookup: O(log(number of runs))
- Construction: O(n log n) due to sorting