# packages/adapter-rust/vendor/codelldb/darwin-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/tenacity/retry.py
@source-hash: 8ebcc3fe6c40e664
@generated: 2026-02-09T17:59:22Z

## Purpose
Defines retry condition strategies for the tenacity library, providing composable predicates that determine whether a failed operation should be retried based on exceptions, results, or combinations thereof.

## Core Architecture

### Base Class
- **retry_base (L25-37)**: Abstract base class defining the retry strategy interface
  - Abstract `__call__(retry_state)` method returns bool indicating retry decision
  - Supports composition via `__and__` (creates retry_all) and `__or__` (creates retry_any)
  - **RetryBaseT (L39)**: Type alias supporting both retry_base instances and callable predicates

### Singleton Strategies
- **_retry_never/_retry_always (L42-59)**: Simple strategies with singleton instances
  - `retry_never`: Always returns False (never retry)
  - `retry_always`: Always returns True (always retry)

### Exception-Based Strategies
- **retry_if_exception (L62-79)**: Base class for exception predicate strategies
  - Takes callable predicate, applies to caught exceptions
  - Validates retry_state.outcome exists and failed before checking predicate

- **retry_if_exception_type (L81-93)**: Retries on specific exception types
  - Accepts single type or tuple of types (defaults to Exception)
  - Uses isinstance() check via lambda predicate

- **retry_if_not_exception_type (L95-107)**: Inverse of exception_type check
  - Retries when exception is NOT one of specified types

- **retry_unless_exception_type (L109-134)**: Retries until specific exception occurs
  - Always retries on success (L127-128)
  - Only stops retrying when specified exception type is raised

- **retry_if_exception_cause_type (L136-164)**: Checks exception cause chain
  - Recursively examines `__cause__` attribute up the exception chain
  - Retries if any cause matches specified types

- **retry_if_exception_message (L198-227)**: Matches exception messages
  - Supports exact string match (`message` parameter) or regex (`match` parameter)
  - Mutually exclusive parameters with validation (L206-207, L224)
  - Compiles regex pattern for efficiency (L217)

- **retry_if_not_exception_message (L229-253)**: Inverse message matching
  - Inherits from retry_if_exception_message, inverts predicate (L239-240)
  - Always retries on success, stops only when message matches

### Result-Based Strategies
- **retry_if_result (L166-180)**: Retries based on successful result values
  - Only evaluates predicate on successful outcomes
  - Returns False for failed outcomes

- **retry_if_not_result (L182-196)**: Inverse result checking
  - Retries when result does NOT satisfy predicate

### Composition Strategies
- **retry_any (L255-263)**: Logical OR composition
  - Retries if ANY child strategy returns True
  - Uses Python's built-in `any()` function

- **retry_all (L265-272)**: Logical AND composition  
  - Retries only if ALL child strategies return True
  - Uses Python's built-in `all()` function

## Key Dependencies
- **RetryCallState**: Referenced type from main tenacity module (L22)
- **abc**: Used for abstract base class pattern
- **re**: For regex pattern matching in message strategies
- **typing**: Comprehensive type annotations throughout

## Critical Patterns
- All strategies validate retry_state.outcome exists before evaluation
- Exception strategies check outcome.failed before accessing exception
- Consistent error handling with RuntimeError for invalid states
- Composition support through operator overloading (__and__, __or__)
- Predicate-based design enabling flexible condition checking