# packages/adapter-rust/vendor/codelldb/darwin-arm64/lldb/lib/python3.12/site-packages/pip/_internal/resolution/legacy/resolver.py
@source-hash: dc766224145dd454
@generated: 2026-02-09T17:57:31Z

## Primary Purpose
Legacy dependency resolver for pip that implements breadth-first "first found, wins" resolution strategy. This resolver handles top-level and sub-dependency requirements, performs package preparation, and determines installation order while managing conflicts and constraints.

## Key Architecture

**Resolver Class (L109-152)**
- Main resolver inheriting from BaseResolver
- Manages upgrade strategies: "eager", "only-if-needed", "to-satisfy-only" (L114)
- Tracks discovered dependencies via DiscoveredDependencies type alias (L52)
- Core configuration includes Python version info, preparer, finder, and various behavioral flags

## Core Resolution Flow

**resolve() Method (L154-189)**
- Entry point that processes root requirements and returns RequirementSet
- Iteratively resolves dependencies via _resolve_one() for each requirement
- Collects and raises any hash errors encountered during resolution

**_resolve_one() Method (L487-568)**
- Processes single requirement and returns additional dependencies to resolve
- Calls _get_dist_for() to prepare distributions and _check_dist_requires_python() for compatibility
- Uses nested add_req() function to recursively add sub-dependencies
- Handles extras validation and warns about missing extras

## Requirement Management

**_add_requirement_to_set() Method (L191-304)**
- Core logic for adding requirements to the resolution set
- Handles marker evaluation, wheel compatibility, and conflict detection
- Implements "double requirement" prevention for top-level specs
- Manages constraint vs regular requirement relationships
- Returns tuple of additional requirements to scan and the added requirement

## Installation Preparation

**_get_dist_for() Method (L441-485)**
- Prepares distributions for installation (editable, installed, or linked)
- Calls _check_skip_installed() and _populate_link() for requirement preparation
- Handles upgrade/reinstall logic based on configuration

**_populate_link() Method (L402-439)**
- Finds and sets requirement links via PackageFinder
- Integrates wheel cache when available and hashes not required
- Updates download info from cache entries

## Utility Functions

**_check_dist_requires_python() (L55-106)**
- Validates Python version compatibility against distribution's Requires-Python
- Handles malformed specifiers with warnings
- Raises UnsupportedPythonVersion when incompatible

**get_installation_order() Method (L570-597)**
- Creates topological installation order using recursive schedule() function
- Ensures dependencies are installed before dependents
- Breaks cycles arbitrarily while maintaining user-specified order where possible

## Key Dependencies
- PackageFinder for locating packages
- RequirementPreparer for distribution preparation  
- WheelCache for caching built wheels
- RequirementSet for managing requirement collections

## Critical Constraints
- Top-level requirements allow only one spec per project (L6-7)
- Sub-dependencies use breadth-first "first found, wins" resolution (L10)
- Upgrade strategies strictly control when packages can be upgraded
- Hash validation disables wheel cache usage for security