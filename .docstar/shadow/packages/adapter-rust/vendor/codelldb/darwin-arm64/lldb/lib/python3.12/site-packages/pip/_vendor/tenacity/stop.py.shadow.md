# packages/adapter-rust/vendor/codelldb/darwin-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/tenacity/stop.py
@source-hash: 60c26ced98197cd0
@generated: 2026-02-09T17:59:17Z

## Purpose
Defines stop condition strategies for the tenacity retry library. Implements a composable system of stop conditions that determine when retry attempts should cease based on various criteria.

## Core Architecture

### Abstract Base Class
- **stop_base (L27-38)**: Abstract base class defining the stop strategy interface
  - `__call__(retry_state)` (L31): Abstract method returning bool to indicate if retrying should stop
  - `__and__` (L34): Combines conditions with logical AND via `stop_all`
  - `__or__` (L37): Combines conditions with logical OR via `stop_any`

### Composition Classes
- **stop_any (L44-51)**: OR combinator - stops when ANY condition is met
  - Accepts multiple stop conditions in constructor
  - Uses `any()` generator expression for evaluation
- **stop_all (L54-61)**: AND combinator - stops when ALL conditions are met
  - Uses `all()` generator expression for evaluation

### Concrete Stop Strategies
- **_stop_never (L64-68)**: Always returns False, never stops retrying
  - Singleton instance `stop_never` (L71)
- **stop_when_event_set (L74-81)**: Stops when threading.Event is set
  - Useful for external cancellation signals
- **stop_after_attempt (L84-91)**: Stops after reaching maximum attempt count
  - Uses `>=` comparison with `retry_state.attempt_number`
- **stop_after_delay (L94-103)**: Stops after maximum time elapsed since first attempt
  - Converts time units via `_utils.to_seconds()` (L98)
  - Validates `seconds_since_start` is available (L101-102)

## Dependencies
- `pip._vendor.tenacity._utils`: Time unit conversion utilities
- `pip._vendor.tenacity.RetryCallState`: State object containing retry metadata
- `threading.Event`: For event-based stopping (type-checking only)

## Key Types
- **StopBaseT (L41)**: Union type allowing either stop_base instances or callable functions

## Patterns
- Functional composition via operator overloading (`__and__`, `__or__`)
- Callable protocol pattern - all stop strategies are callable objects
- Type-safe forward references for circular dependencies
- Singleton pattern for `stop_never` instance