# packages/adapter-rust/vendor/codelldb/darwin-arm64/lldb/lib/python3.12/site-packages/pip/_internal/req/req_set.py
@source-hash: 8f77ac1b4b3a4b3a
@generated: 2026-02-09T17:58:35Z

## Purpose
Container class for managing a collection of Python package requirements during pip installation. Maintains both named and unnamed requirements with deduplication and provides filtering for installable requirements.

## Key Components

**RequirementSet class (L12-82)**
- Primary container for InstallRequirement objects
- Maintains two collections: named requirements in OrderedDict and unnamed requirements in list
- Constructor accepts `check_supported_wheels` parameter for wheel compatibility validation

**Core Data Structures**
- `requirements: Dict[str, InstallRequirement]` (L16) - Maps canonicalized package names to requirements
- `unnamed_requirements: List[InstallRequirement]` (L19) - Requirements without package names
- `check_supported_wheels: bool` (L17) - Controls wheel compatibility checking

**Requirement Management Methods**
- `add_named_requirement()` (L45-49) - Adds requirement with name, canonicalizes package name as key
- `add_unnamed_requirement()` (L41-43) - Adds requirement without name to separate list
- `has_requirement()` (L51-57) - Checks existence of non-constraint requirement by name
- `get_requirement()` (L59-65) - Retrieves requirement by name, raises KeyError if not found

**Access Properties**
- `all_requirements` (L68-69) - Combines unnamed and named requirements into single list
- `requirements_to_install` (L72-82) - Filters requirements needing installation (non-constraints, non-satisfied)

**String Representations**
- `__str__()` (L21-26) - Returns space-separated requirement strings, excludes derived requirements
- `__repr__()` (L28-39) - Debug representation showing class name, count, and requirement list

## Dependencies
- Uses `canonicalize_name` from pip._vendor.packaging.utils for name normalization
- Depends on `InstallRequirement` from pip._internal.req.req_install
- OrderedDict maintains insertion order for named requirements

## Key Patterns
- Name canonicalization ensures consistent requirement lookup across different name formats
- Separation of named vs unnamed requirements handles edge cases in requirement specification
- Constraint filtering in `has_requirement()` and `requirements_to_install` distinguishes between constraints and actual installation targets