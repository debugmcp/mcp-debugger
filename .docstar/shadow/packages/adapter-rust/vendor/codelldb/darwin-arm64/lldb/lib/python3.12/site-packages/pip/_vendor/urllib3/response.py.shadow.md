# packages/adapter-rust/vendor/codelldb/darwin-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/urllib3/response.py
@source-hash: 7e60c9005906ef5b
@generated: 2026-02-09T17:59:34Z

## Purpose
HTTP response handling module for urllib3 with content decoding, streaming, and io.IOBase compatibility. Provides comprehensive response processing including deflate/gzip/brotli decompression, chunked transfer encoding, and connection management.

## Key Components

### Content Decoders
- **DeflateDecoder (L35-65)**: Handles deflate compression with fallback handling for different zlib window sizes. Uses `_first_try` flag to attempt standard deflate first, then raw deflate on failure.
- **GzipDecoder (L74-102)**: Multi-member gzip stream decoder with state management (`GzipDecoderState`). Handles concatenated gzip streams and trailing garbage gracefully.
- **BrotliDecoder (L106-121)**: Optional brotli decoder supporting both 'brotlipy' and 'Brotli' packages via dynamic method binding.
- **MultiDecoder (L123-142)**: Handles multiple content encodings applied in sequence, decoding in reverse order per RFC7231.
- **_get_decoder (L144-154)**: Factory function returning appropriate decoder based on content-encoding header.

### Core Response Class
**HTTPResponse (L157-879)**: Main response container extending io.IOBase for stream compatibility.

#### Key Attributes:
- `CONTENT_DECODERS` (L190-192): Supported compression formats
- `REDIRECT_STATUSES` (L193): HTTP redirect status codes
- `_decoder`, `_body`, `_fp`: Internal state for decoding and content
- `chunked`, `chunk_left`: Chunked transfer encoding state
- `length_remaining`: Content-length tracking

#### Key Methods:
- **`__init__` (L195-261)**: Complex initialization handling headers, body content, chunked encoding detection, and optional preloading
- **`get_redirect_location` (L262-273)**: Returns redirect URL for redirect status codes
- **`release_conn`/`drain_conn` (L275-291)**: Connection lifecycle management
- **`data` property (L293-301)**: Lazy-loaded body content with backward compatibility
- **`_init_length` (L317-367)**: Content-Length header parsing with RFC validation, handles multiple values and edge cases
- **`_init_decoder` (L369-386)**: Decoder initialization based on content-encoding header
- **`_decode` (L392-412)**: Content decoding with error handling and decoder flushing
- **`_error_catcher` (L425-479)**: Context manager for exception translation and cleanup
- **`_fp_read` (L481-527)**: Platform-specific large read handling to avoid 32-bit integer overflow issues
- **`read` (L529-599)**: Main read method with caching, decoding, and content-length enforcement
- **`stream` (L601-626)**: Generator-based streaming with chunked/regular mode detection
- **`from_httplib` (L627-657)**: Class method for converting stdlib HTTPResponse objects

#### Chunked Transfer Support:
- **`supports_chunked_reads` (L738-745)**: Capability detection
- **`_update_chunk_length` (L747-759)**: Chunk size parsing from hex
- **`_handle_chunk` (L761-781)**: Individual chunk processing
- **`read_chunked` (L783-851)**: Full chunked response reading with proper CRLF handling

#### IO Interface:
- Standard io.IOBase methods: `close`, `closed`, `fileno`, `flush`, `readable`, `readinto`
- Iterator support for line-by-line reading (L864-879)
- Backward compatibility methods for http.client.HTTPResponse

## Dependencies
- Core: `io`, `logging`, `zlib`, `contextlib`
- Network: `socket` (SocketError, SocketTimeout)
- urllib3: `util`, `_collections.HTTPHeaderDict`, `connection`, `exceptions`
- Optional: `brotli` (L12, conditionally imported)

## Architecture Patterns
- **Lazy initialization**: Decoders created on-demand via `_init_decoder`
- **Context management**: `_error_catcher` ensures proper cleanup
- **Factory pattern**: `_get_decoder` creates appropriate decoders
- **State machines**: GzipDecoder uses explicit states for multi-member handling
- **Compatibility layers**: Multiple methods for backward compatibility with http.client

## Critical Invariants
- Content-Length and Transfer-Encoding: chunked are mutually exclusive per RFC 7230
- Chunk reading requires fp.fp attribute (httplib compatibility)
- Large reads (>2GB-1) handled specially for CPython <3.10 and pyOpenSSL
- Connection lifecycle tied to response lifecycle with automatic cleanup
- Decoder flushing only on complete reads or explicit flush calls