# packages/adapter-rust/vendor/codelldb/darwin-arm64/lldb/lib/python3.12/site-packages/pip/_internal/resolution/resolvelib/requirements.py
@source-hash: ec91b867bd9ee589
@generated: 2026-02-09T17:57:31Z

## Purpose
Defines concrete requirement classes for pip's resolvelib-based dependency resolver. These classes implement different types of package requirements that can be satisfied by candidates during dependency resolution.

## Core Classes

**ExplicitRequirement (L12-48)**
- Wraps a specific candidate as a requirement (pin to exact version/source)
- Used when a requirement must be satisfied by a particular candidate instance
- Key methods: `is_satisfied_by()` returns True only for the exact wrapped candidate

**SpecifierRequirement (L50-120)**
- Represents version specifier-based requirements (e.g., `>=1.0,<2.0`)
- Backed by `InstallRequirement` with version constraints but no direct links
- Implements caching for equality checks (`_equal_cache`) and hash values (`_hash`)
- Key methods:
  - `is_satisfied_by()` (L109-119): Uses packaging specifiers to check version compatibility
  - `format_for_error()` (L93-104): Formats comma-separated specifiers as human-readable text

**SpecifierWithoutExtrasRequirement (L122-154)**
- Extends `SpecifierRequirement` but strips extras from the install requirement
- Used for base package requirements where extras should be ignored
- Calls `install_req_drop_extras()` in constructor (L130)

**RequiresPythonRequirement (L156-208)**
- Handles Python version requirements from package metadata
- Stores both a `SpecifierSet` for version constraints and a matching candidate
- `get_candidate_lookup()` (L197-200): Returns the candidate only if it satisfies the specifier

**UnsatisfiableRequirement (L210-244)**
- Represents requirements that cannot be satisfied by any candidate
- Always returns `False` from `is_satisfied_by()` (L244-245)
- Used as a fallback for impossible dependency constraints

## Key Dependencies
- `pip._vendor.packaging`: Version specifier handling and name canonicalization
- `pip._internal.req`: Install requirement construction and manipulation
- `.base`: Base `Requirement` interface, `Candidate` type, and utility functions

## Architecture Patterns
- All classes implement the `Requirement` protocol from `.base`
- Consistent caching strategy across specifier-based requirements
- Factory pattern via `get_candidate_lookup()` returning `(candidate, install_req)` tuples
- Immutable design with `frozenset` for extras and cached hash values

## Critical Invariants
- Specifier-backed requirements assert `ireq.link is None` (no direct URLs)
- Candidate name matching enforced in `is_satisfied_by()` methods
- Prerelease handling always enabled since PackageFinder handles filtering
- Hash and equality methods must be consistent for proper resolver operation