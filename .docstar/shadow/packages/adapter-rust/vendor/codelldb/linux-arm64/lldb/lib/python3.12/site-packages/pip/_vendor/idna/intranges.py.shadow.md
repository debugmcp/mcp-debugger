# packages/adapter-rust/vendor/codelldb/linux-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/idna/intranges.py
@source-hash: 601af87d162e587e
@generated: 2026-02-09T18:00:33Z

**Purpose**: Optimized integer range compression and lookup utility for IDNA (Internationalized Domain Names) processing. Converts lists of integers into compact range representations and provides O(log n) membership testing.

**Core Algorithm**: 
- Compresses consecutive integer sequences into (start, end) ranges
- Encodes ranges as single 64-bit integers using bit manipulation (start in high 32 bits, end in low 32 bits)
- Uses binary search for efficient range containment testing

**Key Functions**:
- `intranges_from_list(list_: List[int]) -> Tuple[int, ...]` (L11-30): Main compression function that converts integer list to encoded range tuple. Sorts input, identifies consecutive runs, and encodes each range.
- `intranges_contain(int_: int, ranges: Tuple[int, ...]) -> bool` (L39-54): O(log n) membership test using binary search on encoded ranges. Handles edge cases where target could be at range boundaries.
- `_encode_range(start: int, end: int) -> int` (L32-33): Bit-packs range into single integer using left shift and OR operations.
- `_decode_range(r: int) -> Tuple[int, int]` (L35-36): Unpacks encoded range using right shift and bit masking.

**Dependencies**: 
- `bisect` module for binary search operations
- `typing` for type annotations

**Key Invariants**:
- Ranges use half-open intervals [start, end) 
- Encoded ranges maintain sort order for binary search
- Input integers can contain duplicates (handled by sorting)
- End value in range is exclusive (original_value + 1)

**Architecture Notes**:
- Space-efficient encoding trades bit manipulation complexity for memory savings
- Binary search approach assumes small number of ranges relative to original integer count
- Design optimized for Unicode code point range processing in IDNA context