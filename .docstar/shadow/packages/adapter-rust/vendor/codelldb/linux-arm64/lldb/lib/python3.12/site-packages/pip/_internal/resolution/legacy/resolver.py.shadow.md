# packages/adapter-rust/vendor/codelldb/linux-arm64/lldb/lib/python3.12/site-packages/pip/_internal/resolution/legacy/resolver.py
@source-hash: dc766224145dd454
@generated: 2026-02-09T17:57:58Z

## Primary Purpose
Legacy dependency resolver for pip package installation. Implements a breadth-first resolution strategy with "first found, wins" semantics for sub-dependencies and strict single-spec requirements for top-level packages.

## Core Classes and Functions

### `_check_dist_requires_python()` (L55-107)
Validates Python version compatibility against distribution's `Requires-Python` metadata. Raises `UnsupportedPythonVersion` for incompatible versions unless `ignore_requires_python` is enabled. Contains legacy string conversion pattern for SpecifierSet handling.

### `Resolver` (L109-597)
Main legacy resolver class inheriting from `BaseResolver`. Manages dependency resolution workflow with configurable upgrade strategies.

**Key Configuration:**
- `_allowed_strategies`: {"eager", "only-if-needed", "to-satisfy-only"} (L114)
- Upgrade strategy validation and Python version normalization (L131-136)
- Discovered dependencies tracking via `DiscoveredDependencies` type alias (L152)

**Core Resolution Methods:**

#### `resolve()` (L154-189)
Primary entry point orchestrating resolution process. Builds `RequirementSet`, processes root requirements, handles hash validation errors, and prepares packages for installation.

#### `_add_requirement_to_set()` (L191-304)
Complex requirement addition logic handling:
- Environment marker filtering (L213-219)
- Wheel compatibility validation (L225-231)
- Conflict detection for top-level requirements (L251-264)
- Constraint vs requirement merging (L275-304)

#### `_resolve_one()` (L487-568)
Single requirement resolution with dependency discovery:
- Distribution preparation via `_get_dist_for()` (L505)
- Python compatibility checking (L508-512)
- Recursive dependency processing with `add_req` closure (L516-530)
- Extra requirements validation and warning (L551-560)

**Installation Management:**

#### `_check_skip_installed()` (L326-378)
Determines if installed packages should be skipped, upgraded, or reinstalled based on:
- Force reinstall flags
- Upgrade strategy settings  
- Version availability checks via `PackageFinder`

#### `_populate_link()` (L402-439)
Link resolution and wheel cache integration. Handles cache entry retrieval and download info propagation.

#### `get_installation_order()` (L570-597)
Generates topological installation order using recursive `schedule()` function. Breaks cycles arbitrarily while respecting dependency precedence.

## Key Dependencies
- `PackageFinder`: Package discovery and version selection
- `RequirementPreparer`: Package preparation and caching
- `WheelCache`: Wheel caching functionality
- `BaseDistribution`: Distribution metadata access
- Various pip internal utilities for compatibility, logging, and validation

## Architectural Patterns
- Legacy breadth-first resolution with explicit conflict handling
- Stateful resolver with discovered dependencies tracking
- Integrated preparation and resolution phases
- Extensive validation and error handling throughout resolution pipeline
- Wheel cache optimization with hash verification bypass

## Critical Invariants
- Single specification per top-level requirement (enforced L251-264)
- User-supplied requirements cannot have parents (L234-236)
- Topological installation ordering maintained (L570-597)
- Python version compatibility enforced unless explicitly ignored