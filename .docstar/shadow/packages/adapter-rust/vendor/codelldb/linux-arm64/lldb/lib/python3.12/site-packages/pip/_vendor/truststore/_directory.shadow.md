# packages/adapter-rust/vendor/codelldb/linux-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/truststore/
@generated: 2026-02-09T18:16:07Z

## Overview
The `truststore` package is a cross-platform library that enables certificate verification using native operating system trust stores instead of bundled CA certificates. It provides a drop-in replacement for Python's standard `ssl.SSLContext` that integrates with Windows CryptoAPI, macOS Security Framework, and Linux OpenSSL certificate stores.

## Core Architecture

**Multi-Platform Abstraction**: The package implements a platform detection and delegation pattern:
- **Windows**: Uses CryptoAPI and Windows certificate stores via ctypes (`_windows.py`)
- **macOS**: Integrates with Security/CoreFoundation frameworks via ctypes (`_macos.py`) 
- **Linux/OpenSSL**: Leverages system CA certificate files and OpenSSL defaults (`_openssl.py`)

**API Facade Pattern**: Clean separation between public interface (`__init__.py`) and internal implementation (`_api.py`), with platform-specific modules providing backend implementations.

## Public API Surface

**Main Entry Points** (exposed via `__init__.py`):
- `SSLContext`: Drop-in replacement for `ssl.SSLContext` that uses OS certificate stores
- `inject_into_ssl()`: Globally replaces `ssl.SSLContext` with truststore implementation (includes urllib3 compatibility)
- `extract_from_ssl()`: Restores original SSL context, reversing injection

## Key Components Integration

**SSLContext Implementation** (`_api.py`):
- Wraps standard `ssl.SSLContext` using proxy/decorator pattern
- Implements `__class__` property hack for third-party library compatibility
- Delegates certificate verification to platform-specific implementations
- Uses context managers with `_configure_context()` to temporarily disable built-in verification

**Platform Backends**:
- Each platform module provides `_configure_context()` and `_verify_peercerts_impl()` functions
- **Windows**: Two-tier verification (system store â†’ custom CAs), extensive CryptoAPI bindings
- **macOS**: Security Framework integration with proper CFRelease memory management  
- **OpenSSL**: Fallback search across common Linux CA certificate locations

**Cross-Platform Compatibility** (`_ssl_constants.py`):
- Handles CPython vs non-CPython implementation differences
- Preserves original SSL context references for restoration
- Provides utility functions for SSL context manipulation

## Data Flow

1. **Initialization**: Client imports trigger platform detection and backend selection
2. **Context Creation**: `SSLContext()` wraps standard SSL context with OS-specific certificate verification
3. **Connection Time**: `wrap_socket()`/`wrap_bio()` methods inject custom verification logic
4. **Certificate Verification**: Platform-specific `_verify_peercerts_impl()` validates against OS trust stores
5. **Error Handling**: Platform errors converted to standard SSL exceptions

## Important Patterns

**Resource Management**: Extensive use of context managers and proper cleanup (especially for Windows/macOS native resources)

**Fallback Strategy**: OpenSSL backend searches multiple CA certificate locations; Windows implementation falls back to custom CAs

**Monkey Patching**: Global SSL module injection with proper restoration capabilities

**Memory Safety**: Platform backends implement proper native memory management (CFRelease on macOS, Windows handle cleanup)

## Dependencies
- Python 3.10+ requirement (hard constraint)
- Platform-specific: Windows (ctypes + CryptoAPI), macOS (Security/CoreFoundation), Linux (OpenSSL)
- Standard library: `ssl`, `sys`, `os`, `contextlib`, `typing`