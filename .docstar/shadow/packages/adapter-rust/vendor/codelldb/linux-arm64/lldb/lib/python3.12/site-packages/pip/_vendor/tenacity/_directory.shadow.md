# packages/adapter-rust/vendor/codelldb/linux-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/tenacity/
@generated: 2026-02-09T18:16:16Z

## Tenacity Retry Library

The tenacity directory provides a comprehensive Python retry/backoff library designed for robust handling of transient failures in function execution. It implements a flexible, strategy-based architecture that allows fine-grained control over retry behavior through configurable policies.

### Overall Purpose and Responsibility

This module serves as a complete retry framework that can wrap any callable with intelligent retry logic. It handles temporary failures through configurable strategies for:
- **When to retry** (retry conditions based on exceptions or results)
- **When to stop** (attempt limits, time limits, external events)
- **How long to wait** (fixed, exponential, random backoff strategies)
- **What to do before/after attempts** (logging, custom callbacks)

### Key Components and Architecture

**Core Framework (`__init__.py`)**:
- `BaseRetrying`: Abstract base class providing the retry orchestration engine
- `Retrying`: Synchronous retry controller for regular functions
- `RetryCallState`: State container tracking attempt history and timing
- `AttemptManager`: Context manager for individual retry attempts
- `@retry` decorator: Main entry point with automatic async detection

**Async Support**:
- `AsyncRetrying` (`_asyncio.py`): Native async/await support using asyncio
- `TornadoRetrying` (`tornadoweb.py`): Tornado web framework integration

**Strategy Modules** (Plugin Architecture):
- `retry.py`: Conditions determining when to retry (exception types, results, messages)
- `stop.py`: Conditions determining when to stop retrying (attempts, time, events)
- `wait.py`: Backoff strategies between attempts (fixed, exponential, random)
- `before.py`/`after.py`/`before_sleep.py`: Callback hooks for logging and custom actions
- `nap.py`: Sleep implementations including interruptible delays

**Utilities**:
- `_utils.py`: Time conversion, callback name resolution, ordinal formatting

### Public API Surface

**Primary Entry Points**:
```python
@retry  # Main decorator with auto-detection
@retry(stop=stop_after_attempt(3), wait=wait_exponential())
```

**Programmatic Interface**:
```python
retrying = Retrying(stop=stop_after_delay(10), retry=retry_if_exception_type(IOError))
result = retrying(my_function, *args, **kwargs)
```

**Async Usage**:
```python
async_retrying = AsyncRetrying(...)
result = await async_retrying(async_function, *args, **kwargs)
```

### Internal Organization and Data Flow

1. **Configuration Phase**: User combines strategies (retry conditions, stop conditions, wait strategies, callbacks)
2. **Execution Phase**: 
   - `AttemptManager` wraps each attempt in exception handling
   - `RetryCallState` tracks attempt history and timing
   - Strategy objects evaluate current state to determine next action
3. **Decision Flow**: BaseRetrying.iter() implements state machine with `DoAttempt`/`DoSleep` actions
4. **Async Integration**: Specialized retry classes handle coroutines while preserving the same strategy interface

### Strategy Pattern Implementation

The library uses extensive strategy composition where each aspect of retry behavior is pluggable:
- **Retry Conditions**: `retry_if_exception_type`, `retry_if_result`, logical combinators
- **Stop Conditions**: `stop_after_attempt`, `stop_after_delay`, event-based stopping  
- **Wait Strategies**: `wait_fixed`, `wait_exponential`, `wait_random`, jitter variations
- **Callbacks**: Before/after hooks for logging and custom instrumentation

### Key Design Patterns

- **Strategy Pattern**: All retry behavior aspects are pluggable strategies
- **Decorator Pattern**: `@retry` decorator for transparent function wrapping  
- **State Machine**: `DoAttempt`/`DoSleep` actions control retry flow
- **Context Manager**: `AttemptManager` for safe exception handling
- **Factory Pattern**: Strategy creation functions with configuration parameters
- **Composition**: Strategies can be combined with operators (`&`, `|`, `+`)

### Critical Integration Points

- **Thread Safety**: Thread-local statistics prevent cross-thread contamination
- **Exception Preservation**: Full traceback information maintained through retry cycles
- **Async Compatibility**: Automatic detection and appropriate retry class selection
- **Framework Integration**: Specific support for Tornado, extensible to other async frameworks
- **Testing Support**: Mockable sleep functions and interruptible delays

The library provides a clean separation between retry orchestration logic and configurable strategies, enabling both simple use cases (`@retry`) and complex enterprise scenarios with custom conditions and callbacks.