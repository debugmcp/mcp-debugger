# packages/adapter-rust/vendor/codelldb/linux-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/resolvelib/resolvers.py
@source-hash: 1bcaec2d94aaeb88
@generated: 2026-02-09T18:00:55Z

**Dependency Resolver Core Module**

This module implements the main resolution algorithm for dependency conflicts using backtracking and state management. It's part of the pip resolvelib package that handles complex dependency resolution scenarios.

## Core Components

**RequirementInformation** (L8-10): Named tuple representing a requirement and its parent dependency.

**Exception Hierarchy** (L13-99):
- `ResolverException` (L13-18): Base exception for all resolver errors
- `RequirementsConflicted` (L21-30): Raised when requirements cannot be satisfied together
- `InconsistentCandidate` (L32-43): Raised when a candidate doesn't satisfy its criterion
- `ResolutionError` (L84-85): Base for resolution-specific errors
- `ResolutionImpossible` (L88-93): Terminal failure with causes list
- `ResolutionTooDeep` (L95-99): Max rounds exceeded (circular dependency protection)

**Criterion** (L45-83): Immutable container holding:
- `candidates`: Possible resolution candidates
- `information`: List of RequirementInformation pairs
- `incompatibilities`: Known bad candidates to exclude
- Key methods: `iter_requirement()` (L77), `iter_parent()` (L80)

**State** (L102): Named tuple for resolution round state: `(mapping, criteria, backtrack_causes)`

## Main Resolution Engine

**Resolution** (L105-458): Core stateful resolver with backtracking:
- `__init__(provider, reporter)` (L112): Takes provider for dependency queries and reporter for events
- `state` property (L117): Returns current state from stack
- `_push_new_state()` (L124): Creates new resolution round state
- `_add_to_criteria(criteria, requirement, parent)` (L138): Adds requirement to criterion, finds matches
- `_remove_information_from_criteria(criteria, parents)` (L177): Cleans up invalidated parent info
- `_attempt_to_pin_criterion(name)` (L233): Tries to pin a candidate, returns failure causes
- `_backjump(causes)` (L270): Complex backtracking algorithm to undo failed pins
- `resolve(requirements, max_rounds)` (L381): Main entry point performing iterative resolution

## Resolution Algorithm Flow

1. Initialize root state with empty mapping/criteria
2. Add initial requirements to criteria
3. For each round (up to max_rounds):
   - Find unsatisfied criteria
   - Select most preferred criterion to pin
   - Attempt to pin candidate:
     - If successful: push new state, continue
     - If failed: backjump to previous valid state
4. Return final resolution or raise appropriate exception

**Helper Functions**:
- `_has_route_to_root(criteria, key, all_keys, connected)` (L460): Checks connectivity to root
- `_build_result(state)` (L482): Constructs final Result with mapping, graph, criteria

**Result** (L479): Named tuple containing final resolution: `(mapping, graph, criteria)`

**Resolver** (L512-547): Public API class inheriting from AbstractResolver:
- `resolve(requirements, max_rounds=100)` (L517): Main public interface
- Returns Result tuple with resolved mapping, dependency graph, and detailed criteria

## Key Dependencies

- `providers.AbstractResolver`: Base class for resolver interface
- `structs.DirectedGraph, IteratorMapping, build_iter_view`: Data structures
- Provider interface methods: `identify()`, `find_matches()`, `get_dependencies()`, `is_satisfied_by()`, `get_preference()`

## Architecture Notes

- Uses state stack for backtracking capability
- Immutable Criterion objects prevent accidental mutation
- Reporter interface allows external monitoring of resolution process
- Provider pattern abstracts package/dependency queries
- Graph construction tracks dependency relationships for final result