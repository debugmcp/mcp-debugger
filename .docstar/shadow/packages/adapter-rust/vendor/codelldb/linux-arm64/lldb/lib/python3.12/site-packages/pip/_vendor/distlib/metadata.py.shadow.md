# packages/adapter-rust/vendor/codelldb/linux-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/distlib/metadata.py
@source-hash: a41f5667d9817e64
@generated: 2026-02-09T18:00:54Z

## Python Package Metadata Handler

**Primary Purpose**: Implements Python package metadata parsing, validation, and manipulation for all PEP metadata formats (1.0, 1.1, 1.2, 1.3/2.1, and 2.2).

### Key Classes

**LegacyMetadata (L245-603)**: Handles legacy metadata formats (1.0-2.2) using key-value PKG-INFO style format.
- `__init__(path, fileobj, mapping, scheme)` (L257-271): Constructor supports file path, file object, or mapping input
- `read(filepath)` / `read_file(fileobj)` (L339-374): Parse metadata from files using email.message_from_file
- `write(filepath)` / `write_file(fileobj)` (L375-406): Output PKG-INFO format with version-specific field handling
- `set(name, value)` (L436-478): Validates and stores metadata fields with type coercion
- `get(name, default)` (L480-507): Retrieves metadata with proper type handling for lists/tuples
- `check(strict=False)` (L509-551): Validates metadata completeness and field formats
- `todict(skip_missing=False)` (L553-574): Converts to underscore-lowercase dict format per PEP 566

**Metadata (L610-1063)**: Modern metadata handler preferring 2.1 format, wrapping LegacyMetadata when needed.
- `__init__(path, fileobj, mapping, scheme)` (L655-698): Auto-detects format, falls back to legacy for unsupported versions
- `__getattribute__(key)` (L723-764): Dynamic attribute access with mapping between new/legacy field names
- `__setattr__(key, value)` (L776-813): Validates and stores with format-specific handling
- `get_requirements(reqts, extras, env)` (L837-877): Resolves conditional dependencies based on extras and environment markers
- `write(path, fileobj, legacy, skip_unknown)` (L1021-1045): Outputs JSON or legacy format

### Core Functions

**_best_version(fields)** (L136-204): Auto-detects optimal metadata version based on field usage, with version elimination logic.

**_version2fieldlist(version)** (L118-133): Maps metadata versions to allowed field sets.

**_get_name_and_version(name, version, for_filename)** (L232-242): Formats distribution name-version strings with optional filename sanitization.

### Important Constants

- **Field Definitions** (L55-105): Version-specific field tuples (_241_FIELDS, _314_FIELDS, etc.)
- **Field Classifications** (L213-225): Categorizes fields by type (list, predicate, version, unicode, etc.)
- **Field Mappings** (L208-211, L705-719): Bidirectional mapping between attribute names and field names
- **Validation Patterns** (L617-651): Regex patterns for metadata format validation

### Key Dependencies

- `email.message_from_file`: PKG-INFO parsing
- `json`: Modern metadata format handling  
- `.markers.interpret`: Environment marker evaluation
- `.version.get_scheme, PEP440_VERSION_RE`: Version validation
- `.util.extract_by_key, get_extras`: Utility functions

### Architecture Patterns

- **Format Abstraction**: Single interface supporting multiple metadata versions
- **Lazy Legacy Fallback**: Attempts modern format first, gracefully degrades to legacy
- **Field Mapping**: Automatic translation between different field naming conventions
- **Conditional Dependencies**: Sophisticated handling of extras and environment markers
- **Validation Pipeline**: Multi-stage validation with version-specific rules

### Critical Constraints

- Metadata 2.0 is explicitly unsupported (L128-129)
- Field names are case-insensitive with dash/underscore normalization
- List fields require special handling for single-value inputs
- Description field has version-specific line prefix handling for multi-line content
- Mutual exclusivity enforced for path/fileobj/mapping constructor parameters