# packages/adapter-rust/vendor/codelldb/linux-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/platformdirs/
@generated: 2026-02-09T18:16:18Z

## Overall Purpose

This directory contains the **platformdirs** library - a cross-platform Python module that provides standardized access to application-specific directories (data, config, cache, logs, runtime, and user media folders) across Windows, macOS, Linux/Unix, and Android platforms. It abstracts away platform-specific filesystem conventions, allowing applications to store files in appropriate system locations without hardcoding paths.

## Key Components & Architecture

### Entry Point & Public API (`__init__.py`)
The main module provides a unified facade with dual APIs:
- **String-based functions**: `user_data_dir()`, `user_config_dir()`, `user_cache_dir()`, etc. (returns strings)
- **Path-based functions**: `user_data_path()`, `user_config_path()`, `user_cache_path()`, etc. (returns `pathlib.Path` objects)

**Platform Detection**: Runtime detection via `_set_platform_dir_class()` automatically selects the appropriate implementation:
- Windows: `sys.platform == "win32"`
- macOS: `sys.platform == "darwin"`  
- Android: Environment variable detection (`ANDROID_DATA`, `ANDROID_ROOT`)
- Unix/Linux: Default fallback

### Platform-Specific Implementations

**Abstract Base (`api.py`)**:
- `PlatformDirsABC` defines the interface contract with abstract properties for all directory types
- Provides common functionality: path construction utilities, Path object wrappers, iterator methods
- Handles app name/version appending and optional directory creation

**Platform Implementations**:
- **Windows** (`windows.py`): Uses CSIDL constants with three-tier fallback (ctypes→registry→env vars), supports roaming profiles
- **macOS** (`macos.py`): Follows Apple conventions with `~/Library/` paths, includes Homebrew detection  
- **Unix/Linux** (`unix.py`): XDG Base Directory Specification compliant with environment variable overrides
- **Android** (`android.py`): Android filesystem conventions with PyJNIus API integration and fallbacks

### Data Flow & Organization

1. **User Request**: Application calls public API function (e.g., `user_data_dir()`)
2. **Platform Detection**: Factory pattern selects appropriate platform class
3. **Instance Creation**: Platform-specific class instantiated with app metadata
4. **Path Resolution**: Platform implementation resolves base directory using OS-specific methods
5. **Path Construction**: Base class appends app name, version, and optional subdirectories
6. **Directory Creation**: Optional creation if `ensure_exists=True`
7. **Return**: String or Path object returned to caller

## Public API Surface

### Core Directory Functions
- **User Directories**: `user_data_dir/path`, `user_config_dir/path`, `user_cache_dir/path`, `user_state_dir/path`, `user_log_dir/path`, `user_runtime_dir/path`
- **Site/System Directories**: `site_data_dir/path`, `site_config_dir/path`, `site_cache_dir/path`, `site_runtime_dir/path`
- **User Media Directories**: `user_documents_dir/path`, `user_downloads_dir/path`, `user_pictures_dir/path`, `user_videos_dir/path`, `user_music_dir/path`, `user_desktop_dir/path`

### Configuration Parameters
All functions accept standardized parameters:
- `appname`: Application identifier
- `appauthor`: Organization name (can be `False`)  
- `version`: Version suffix for paths
- `roaming`: Windows roaming profile support
- `multipath`: Return multiple paths on Unix/Linux
- `opinion`: Apply opinionated subdirectory defaults
- `ensure_exists`: Auto-create directories

### Classes
- `PlatformDirs`: Main class (dynamically assigned to platform implementation)
- `AppDirs`: Backwards compatibility alias

## Important Patterns & Conventions

### Design Patterns
- **Factory Pattern**: Dynamic platform class selection
- **Template Method**: Base class provides path construction, subclasses implement platform specifics
- **Facade Pattern**: Simple function API wrapping complex platform logic
- **Fallback Strategy**: Multiple resolution methods with graceful degradation

### Caching & Performance
- `@lru_cache` decorators on platform detection and directory resolution functions
- Lazy evaluation of directory paths
- Cached platform-specific helper functions (especially Android)

### Cross-Platform Consistency
- Unified parameter interface across all platforms
- Consistent app name/version path construction
- Dual string/Path APIs for different use cases
- Iterator methods for accessing related directory collections

## Version & Tooling

**Version Management** (`version.py`): Auto-generated by setuptools_scm providing `__version__` string and `__version_tuple__` for programmatic access.

**CLI Demo** (`__main__.py`): Command-line demonstration tool showing directory resolution across different configurations.

The library serves as a critical infrastructure component for Python applications requiring cross-platform file storage, eliminating the need for applications to implement platform-specific directory logic themselves.