# packages/adapter-rust/vendor/codelldb/linux-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/urllib3/util/wait.py
@source-hash: 7ce5f4fdf6a8cc6d
@generated: 2026-02-09T17:57:57Z

Cross-platform socket waiting utilities for urllib3, providing unified interface for polling socket readiness across different operating systems and Python versions.

## Primary Purpose
Abstracts platform differences in socket polling APIs (select/poll) and handles Python version inconsistencies in interrupt handling for blocking socket operations.

## Key Components

**Exception Class:**
- `NoWayToWaitForSocketError` (L14-15): Raised when no socket waiting mechanism is available (e.g., AppEngine)

**Interrupt Handling:**
- `_retry_on_intr()` (L42-67): Handles syscall interruption differently based on Python version
  - Python 3.5+: Direct call (L42-43) - modern Python retries automatically
  - Python <3.5: Manual EINTR retry loop (L47-67) with timeout recalculation

**Core Implementation Functions:**
- `select_wait_for_socket()` (L70-86): Uses select.select() for socket polling
  - Handles Windows quirk: checks exceptional conditions for write readiness (L79-83)
  - Returns boolean indicating socket readiness
- `poll_wait_for_socket()` (L89-106): Uses select.poll() for more efficient polling
  - Converts timeout to milliseconds (L102-103)
  - Preferred on Unix systems for high-numbered file descriptors
- `null_wait_for_socket()` (L109-110): Fallback that always raises exception

**Platform Detection:**
- `_have_working_poll()` (L113-123): Tests if poll() is available and functional
  - Handles broken poll() implementations from libraries like eventlet/greenlet

**Dynamic Function Selection:**
- `wait_for_socket()` (L126-138): Lazy initialization pattern
  - Self-replaces with optimal implementation on first call
  - Priority: poll() → select() → null (exception)
  - Delays decision to handle runtime monkeypatching

**Public API:**
- `wait_for_read()` (L141-145): Convenience wrapper for read readiness
- `wait_for_write()` (L148-152): Convenience wrapper for write readiness

## Architecture Patterns
- **Lazy initialization**: Function selection deferred until first use
- **Platform abstraction**: Single interface across Windows/Unix differences  
- **Graceful degradation**: Falls back through implementations until one works
- **Self-modifying code**: `wait_for_socket` replaces itself with chosen implementation

## Critical Dependencies
- `select` module: Core polling functionality
- `errno.EINTR`: Interrupt signal handling
- `time.monotonic`: Timeout calculations (with time.time fallback for old Python)

## Key Invariants
- At least one of `read=True` or `write=True` must be specified
- Timeout values handled consistently across implementations (None = infinite, 0 = non-blocking)
- All functions return boolean indicating socket readiness state