# packages/adapter-rust/vendor/codelldb/linux-arm64/lldb/lib/python3.12/site-packages/pip/_internal/network/cache.py
@source-hash: e3c03def5a82cca3
@generated: 2026-02-09T18:00:25Z

## Purpose
HTTP cache implementation for pip's internal networking layer. Provides a thread-safe file-based cache that handles race conditions and gracefully degrades when cache directories are inaccessible.

## Key Components

### Utility Functions
- **is_from_cache** (L17-18): Simple predicate to check if a Response object came from cache via `from_cache` attribute
- **suppressed_cache_errors** (L22-29): Context manager that catches and silently ignores OSError exceptions, enabling graceful cache failure handling

### SafeFileCache Class (L32-106)
Primary cache implementation extending `SeparateBodyBaseCache`. Implements a two-file strategy where each cache entry consists of metadata and body files stored separately.

**Key Methods:**
- **__init__** (L50-53): Initializes with directory path, validates non-None directory
- **_get_cache_path** (L55-61): Generates hierarchical cache paths using first 5 chars of hash as subdirectories, inherits encoding from `SeparateBodyFileCache`
- **get** (L63-71): Retrieves metadata, requires both metadata and body files to exist for validity
- **get_body** (L95-102): Returns body file handle, same dual-file validation logic
- **set** (L82-86): Stores metadata using atomic write operations
- **set_body** (L104-106): Stores body content using atomic write operations
- **_write** (L73-80): Atomic write implementation using `adjacent_tmp_file` and `replace` for crash safety
- **delete** (L88-93): Removes both metadata and body files, suppresses errors on each deletion

## Architecture & Dependencies
- Extends `pip._vendor.cachecontrol.cache.SeparateBodyBaseCache`
- Uses `pip._internal.utils.filesystem.{adjacent_tmp_file, replace}` for atomic operations
- Leverages `SeparateBodyFileCache.encode` for key hashing
- Integrates with `pip._internal.utils.misc.ensure_dir` for directory creation

## Critical Design Decisions
1. **Race Condition Mitigation**: Validates both metadata and body files exist before returning entries (addresses CacheControl issue #324)
2. **Write-Side Assumption**: Assumes servers return identical data for identical URLs (critical for PyPI wheel integrity)
3. **Graceful Degradation**: All cache operations wrapped in `suppressed_cache_errors` to continue without caching if filesystem issues occur
4. **Atomic Writes**: Uses temporary files with atomic replacement to prevent corruption during concurrent access

## Invariants
- Cache entries are only valid when both `.metadata` and `.body` files exist
- All write operations must be atomic to prevent partial state
- Cache directory structure: `directory/h/a/s/h/e/hashedkey` with corresponding `.body` file