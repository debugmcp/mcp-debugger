# packages/adapter-rust/vendor/codelldb/linux-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/tenacity/__init__.py
@source-hash: 643e19bd969b7d95
@generated: 2026-02-09T18:01:10Z

## Tenacity Retry Library Core Module

This is the main module of the tenacity library, a comprehensive Python retry/backoff library that provides robust retry mechanisms with configurable strategies for stopping, waiting, and retrying failed operations.

### Primary Purpose
The module provides a decorator-based and programmatic interface for retrying functions with configurable policies for handling failures, exponential backoff, stop conditions, and custom retry logic.

### Key Classes and Their Roles

**TryAgain (L101-103)**: Exception class that forces immediate retry when raised from within a wrapped function.

**BaseAction (L116-134)**: Abstract base class for retry actions. Provides standardized repr() functionality using REPR_FIELDS and NAME class variables.

**RetryAction (L136-142)**: Concrete action representing a retry with sleep duration. Contains sleep field for delay before next attempt.

**RetryError (L151-165)**: Exception raised when all retry attempts are exhausted. Wraps the final failed attempt and provides reraise() method to propagate the original exception.

**AttemptManager (L167-189)**: Context manager for individual retry attempts. Captures exceptions and results during execution, automatically setting state on the retry_state object.

**BaseRetrying (L191-366)**: Abstract base class for retry controllers. Core functionality includes:
- Configuration of retry strategies (stop, wait, retry conditions)
- Statistics collection per thread via threading.local
- Function wrapping with retry_with() method for dynamic configuration
- Iterator protocol support for manual retry control
- Abstract __call__ method for concrete implementations

**Retrying (L368-394)**: Concrete synchronous retry controller. Implements __call__ to execute functions with retry logic, handling exceptions and results according to configured strategies.

**Future (L402-423)**: Enhanced futures.Future subclass tracking attempt numbers. Provides failed property and construct() class method for creating instances from values or exceptions.

**RetryCallState (L425-495)**: State container for retry operations. Tracks:
- Attempt number and timing information
- Function arguments and wrapped function reference
- Outcome (result/exception) and timestamps
- Idle time spent sleeping between attempts
- Next planned action

### Key Functions

**_first_set (L147-148)**: Utility for copy() method - returns second value if first is the _unset sentinel.

**retry (L518-546)**: Main decorator function with dual syntax support (@retry and @retry()). Automatically detects coroutine functions and selects appropriate retry class (AsyncRetrying, TornadoRetrying, or Retrying).

### Important Dependencies
- Comprehensive import of all retry strategies from .retry module (L31-44)
- Sleep strategies from .nap module (L47-48)  
- Stop conditions from .stop module (L51-56)
- Wait strategies from .wait module (L59-68)
- Before/after hooks from respective modules (L71-80)
- AsyncRetrying imported at module level (L548)

### Architectural Patterns
- **Strategy Pattern**: Pluggable retry, stop, wait, and callback strategies
- **Decorator Pattern**: Function wrapping with @retry decorator
- **Iterator Protocol**: BaseRetrying supports iteration for manual control
- **Context Manager**: AttemptManager for exception handling
- **Thread-Local Storage**: Statistics isolated per thread
- **Future Pattern**: Wraps results/exceptions in Future objects

### Critical Invariants
- tornado is hardcoded to None (L87) to prevent pip compatibility issues
- Thread-local statistics prevent cross-thread contamination
- Attempt numbers start at 1 and increment sequentially
- Outcome timestamp tracks when results/exceptions occur
- Copy operations preserve all retry configuration unless explicitly overridden

### Configuration Strategy Integration
The module acts as a central hub importing all strategy implementations, allowing flexible composition of retry behaviors through the BaseRetrying constructor parameters.