# packages/adapter-rust/vendor/codelldb/linux-arm64/lldb/lib/python3.12/site-packages/pip/_vendor/pygments/lexers/__init__.py
@source-hash: 583d6e224d849883
@generated: 2026-02-09T17:58:00Z

## Primary Purpose
Main entry point module for Pygments lexer discovery, loading, and instantiation. Provides public API for finding and creating lexer instances by name, filename, or MIME type, with support for both built-in and plugin lexers.

## Key Functions

### Core Lexer Resolution (L51-132)
- `get_all_lexers(plugins=True)` (L51): Generator yielding tuples of (name, aliases, filenames, mimetypes) for all available lexers
- `find_lexer_class(name)` (L65): Returns lexer class by exact name match without instantiation
- `find_lexer_class_by_name(_alias)` (L83): Returns lexer class by alias match, raises ClassNotFound if not found
- `get_lexer_by_name(_alias, **options)` (L110): Returns instantiated lexer by alias with options

### File-based Lexer Discovery (L170-229)
- `find_lexer_class_for_filename(_fn, code=None)` (L170): Returns lexer class matching filename pattern, uses analyze_text() for disambiguation
- `get_lexer_for_filename(_fn, code=None, **options)` (L213): Returns instantiated lexer for filename, raises ClassNotFound if none found

### Content-based Lexer Guessing (L262-341)
- `guess_lexer_for_filename(_fn, _text, **options)` (L262): Combines filename pattern matching with text analysis for lexer selection
- `guess_lexer(_text, **options)` (L305): Pure text-based lexer guessing using analyze_text() scores, checks vim modelines first

### Custom Lexer Loading (L135-167)
- `load_lexer_from_file(filename, lexername="CustomLexer", **options)` (L135): Loads and instantiates lexer class from arbitrary Python file using exec()

### MIME Type Resolution (L232-248)
- `get_lexer_for_mimetype(_mime, **options)` (L232): Returns instantiated lexer matching MIME type

## Internal Implementation

### Caching System (L31-32, L43-48)
- `_lexer_cache`: Cache for loaded lexer classes to avoid repeated imports
- `_pattern_cache`: Cache for compiled filename pattern regexes
- `_load_lexers(module_name)` (L43): Lazy-loads all lexers from a module into cache

### Pattern Matching (L35-40)
- `_fn_matches(fn, glob)` (L35): Cached filename pattern matching using fnmatch.translate()

### Module Auto-loading (L344-362)
- `_automodule` class (L344): Custom module type that auto-imports lexers on attribute access
- Module replacement system replaces current module with auto-loading version

## Key Dependencies
- `pip._vendor.pygments.lexers._mapping.LEXERS`: Master registry mapping lexer keys to (module, name, aliases, filenames, mimetypes)
- `pip._vendor.pygments.plugin.find_plugin_lexers()`: Plugin lexer discovery via entry points
- `pip._vendor.pygments.modeline.get_filetype_from_buffer()`: Vim modeline parsing for filetype hints
- `pip._vendor.pygments.util.ClassNotFound`: Exception for lexer lookup failures

## Architectural Patterns
- Lazy loading: Lexers loaded on-demand to reduce startup time
- Two-tier lookup: Built-in lexers from LEXERS mapping, then plugin lexers
- Caching strategy: Both lexer classes and filename patterns cached
- Module hijacking: Uses custom module type for transparent lexer imports
- Compatibility layer: COMPAT dict (L22-26) maps old lexer names to new ones

## Critical Constraints
- All lexer lookup functions raise ClassNotFound when no match found
- Text analysis functions expect Unicode strings, bytes are auto-decoded
- Custom lexer loading uses exec() - security risk with untrusted input
- Plugin lexers always checked after built-in lexers
- Filename matching uses basename only, ignoring directory paths