# packages/adapter-rust/vendor/codelldb/darwin-x64/lldb/lib/python3.12/site-packages/pip/_internal/locations/
@generated: 2026-02-09T18:16:10Z

## Overall Purpose

The `pip/_internal/locations` package is pip's central system for resolving Python package installation paths across different platforms, Python versions, and installation contexts. It manages the complex transition from Python's legacy `distutils` to modern `sysconfig` while handling numerous platform-specific quirks, distribution patches, and virtual environment considerations.

## Key Components and Architecture

### Core Orchestration (`__init__.py`)
The main module implements a sophisticated dual-backend system that conditionally uses either `sysconfig` (Python 3.10+) or `distutils` based on configuration flags. It features:
- **Backend comparison and validation**: Compares results from both systems and warns on mismatches
- **Platform detection system**: Cached functions detect Red Hat, Debian, Slackware, MSYS2, and other distribution-specific patches
- **Extensive compatibility handling**: Skip conditions for known platform quirks and Python bugs

### Backend Implementations
- **`_sysconfig.py`**: Modern implementation using Python's `sysconfig` module with special handling for macOS framework builds and virtual environments
- **`_distutils.py`**: Legacy compatibility layer using `distutils` with Unicode-safe config parsing and Windows-specific binary path logic

### Foundation Utilities (`base.py`)
Provides cross-platform utilities for path manipulation, version detection, and environment-specific directory resolution (cache, source, user site-packages).

## Public API Surface

### Primary Entry Points
- **`get_scheme()`**: Main path resolution function returning installation schemes for different contexts (user, home, prefix, virtual environments)
- **`get_bin_prefix()`**: Platform-specific binary/script directory resolution
- **`get_bin_user()`**: User-specific binary installation paths
- **`get_purelib()`/`get_platlib()`**: Pure Python and platform-specific library paths

### Utility Functions
- **`get_major_minor_version()`**: Python version string formatting
- **`change_root()`**: Cross-platform root path manipulation
- **`get_src_prefix()`**: Source directory location resolution
- **`is_osx_framework()`**: macOS framework build detection

## Internal Organization and Data Flow

1. **Request Processing**: Installation path requests flow through `__init__.py`'s `get_scheme()` function
2. **Backend Selection**: Conditional logic chooses between `_sysconfig` and `_distutils` backends
3. **Platform Detection**: Cached platform detection functions identify distribution-specific behaviors
4. **Path Resolution**: Selected backend resolves paths using appropriate Python APIs
5. **Validation**: Results are compared between backends when both are available, with mismatch warnings
6. **Special Case Handling**: Platform-specific adjustments applied (macOS frameworks, Windows paths, Linux distribution patches)

## Important Patterns and Conventions

### Compatibility Strategy
- **Gradual migration**: Maintains both old and new backends during transition period
- **Comparison validation**: Cross-validates results between backends to catch regressions
- **Graceful degradation**: Falls back to working implementations when preferred methods fail

### Platform Abstraction
- **Detection caching**: Platform-specific behaviors detected once and cached with `@functools.lru_cache`
- **Skip conditions**: Extensive logic to bypass comparisons for known incompatible scenarios
- **Error boundaries**: Platform-specific code isolated to prevent cross-contamination

### Virtual Environment Awareness
- **Context detection**: All backends aware of virtual environment vs system Python contexts
- **Path specialization**: Special handling for virtual environment header paths and site-packages structure
- **Prefix handling**: Custom prefix and root parameter support with appropriate path transformations

The package serves as pip's critical infrastructure for determining where packages should be installed, handling the complexity of Python's evolving installation standards while maintaining compatibility across diverse deployment environments.