# packages/adapter-rust/vendor/codelldb/darwin-x64/lldb/lib/python3.12/site-packages/pip/_vendor/tenacity/
@generated: 2026-02-09T18:16:19Z

## Overall Purpose

The `tenacity` directory contains pip's vendored copy of the Tenacity retry library, providing comprehensive retry/resilience mechanisms for Python functions with configurable strategies. This is a complete retry framework that supports both synchronous and asynchronous operations, with explicit Tornado support disabled to avoid version conflicts in pip's environment.

## Core Architecture

The library is built around a **strategy pattern architecture** with four main strategy categories:

1. **Retry Conditions** (`retry.py`): Determine *when* to retry based on exceptions, results, or custom predicates
2. **Stop Conditions** (`stop.py`): Determine *when to give up* based on attempts, time, or events  
3. **Wait Strategies** (`wait.py`): Determine *how long to wait* between attempts using various backoff algorithms
4. **Callback Hooks** (`before.py`, `after.py`, `before_sleep.py`): Execute side effects at different retry lifecycle phases

## Key Components and Relationships

### Core Retry Engine (`__init__.py`)
- **`BaseRetrying`**: Abstract retry controller orchestrating the entire retry process
- **`Retrying`**: Synchronous concrete implementation 
- **`RetryCallState`**: Tracks state across retry attempts (timing, results, attempt count)
- **`AttemptManager`**: Context manager handling attempt execution and exception capture
- **`retry()` decorator**: Main public entry point supporting both `@retry` and `@retry()` syntax

### Async Support (`_asyncio.py`)
- **`AsyncRetrying`**: Async/await compatible retry controller extending `BaseRetrying`
- Integrates with `asyncio.sleep` and preserves async context throughout retry loops
- Supports async iterator protocol for advanced usage patterns

### Strategy Implementations

**Retry Strategies (`retry.py`)**:
- Exception-based: `retry_if_exception_type`, `retry_if_exception_message`, `retry_if_exception_cause_type`
- Result-based: `retry_if_result`, `retry_if_not_result`  
- Composite: `retry_any`, `retry_all` with boolean logic
- Built-ins: `retry_always`, `retry_never`

**Stop Strategies (`stop.py`)**:
- Count-based: `stop_after_attempt`
- Time-based: `stop_after_delay`
- Event-driven: `stop_when_event_set`
- Composite: `stop_any`, `stop_all`

**Wait Strategies (`wait.py`)**:
- Fixed: `wait_fixed`, `wait_none`
- Random: `wait_random`, `wait_random_exponential`
- Progressive: `wait_incrementing`, `wait_exponential`, `wait_exponential_jitter`
- Composite: `wait_combine`, `wait_chain`

## Public API Surface

### Primary Entry Points
- **`@retry`** decorator: Main interface for adding retry behavior to functions
- **`Retrying()`**: Programmatic retry controller for sync operations
- **`AsyncRetrying()`**: Programmatic retry controller for async operations

### Configuration Interface
All retry controllers accept strategy parameters:
```python
@retry(
    retry=retry_if_exception_type(ConnectionError),
    stop=stop_after_attempt(3),
    wait=wait_exponential(multiplier=1, min=4, max=10),
    before=before_log(logger, logging.INFO),
    after=after_log(logger, logging.INFO)
)
```

### Strategy Composition
- All strategy types support composition via operators (`&`, `|`, `+`)
- Enables complex retry logic: `retry_if_exception_type(A) | retry_if_result(predicate)`

## Internal Organization and Data Flow

### Retry Execution Flow
1. **Initialization**: Configure strategies and create `RetryCallState`
2. **Decision Loop**: Call `iter()` to get next action (`DoAttempt` or `DoSleep`)
3. **Attempt Execution**: Use `AttemptManager` to execute function and capture outcome
4. **Strategy Evaluation**: Apply retry/stop/wait strategies to determine next action
5. **Callback Execution**: Run before/after/before_sleep hooks
6. **Result Handling**: Return success or raise `RetryError` with attempt history

### State Management
- **Thread-local statistics**: Track retry metrics per thread
- **Immutable state objects**: `RetryCallState` captures attempt context
- **Future-based results**: Uniform handling of success/exception outcomes

### Utility Infrastructure
- **`_utils.py`**: Time conversions, ordinal formatting, callback name resolution
- **`nap.py`**: Pluggable sleep implementations (time-based, event-based)

## Important Patterns and Conventions

### Design Patterns
- **Strategy Pattern**: All retry behaviors are pluggable strategies
- **Template Method**: `BaseRetrying` defines algorithm, subclasses implement execution
- **Composite Pattern**: Strategies can be combined with boolean/arithmetic operators
- **Decorator Pattern**: `@retry` wraps functions with retry behavior
- **Context Manager**: `AttemptManager` ensures proper exception handling

### Critical Conventions
- Attempt numbers start at 1 (not 0)
- All time values normalized to float seconds via `to_seconds()`
- Exception information preserved through `RetryError` with `reraise()` method  
- Strategies never fail - defensive programming with graceful fallbacks
- Thread-safety via `threading.local` for statistics

### Tornado Integration
- **`tornadoweb.py`**: Provides Tornado-specific retry support
- Uses legacy coroutine syntax for compatibility
- **Note**: Tornado support is explicitly disabled in pip's usage (L538-539 in `__init__.py`)

## Key Dependencies
- Standard library: `asyncio`, `threading`, `time`, `logging`, `random`
- Internal utilities for time conversion and string formatting
- Type system heavily leveraged for API safety and IDE support