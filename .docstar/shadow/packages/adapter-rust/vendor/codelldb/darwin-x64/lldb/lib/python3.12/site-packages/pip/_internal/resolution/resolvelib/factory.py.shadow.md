# packages/adapter-rust/vendor/codelldb/darwin-x64/lldb/lib/python3.12/site-packages/pip/_internal/resolution/resolvelib/factory.py
@source-hash: ab334847f62c0b89
@generated: 2026-02-09T17:57:45Z

## Primary Purpose

Core factory class for pip's ResolveLib-based dependency resolver, responsible for creating and managing candidate packages, requirements, and constraints during dependency resolution. Acts as the central orchestrator between pip's internal components and the ResolveLib resolver.

## Key Classes and Functions

### Factory Class (L95-816)
Main orchestrator class that manages candidate creation, caching, and requirement resolution.

**Key initialization parameters (L96-107):**
- `finder`: PackageFinder for locating packages
- `preparer`: RequirementPreparer for package preparation
- `wheel_cache`: Optional wheel caching mechanism
- Installation control flags: `force_reinstall`, `ignore_installed`, `ignore_requires_python`

**Core caching mechanisms (L117-124):**
- `_build_failures`: Cache failed build attempts to avoid retries
- `_link_candidate_cache`: Cache LinkCandidate objects by Link
- `_editable_candidate_cache`: Cache EditableCandidate objects
- `_installed_candidate_cache`: Cache already installed candidates
- `_extras_candidate_cache`: Cache ExtrasCandidate objects

**Key candidate creation methods:**
- `_make_candidate_from_dist()` (L162-175): Creates candidates from installed distributions
- `_make_candidate_from_link()` (L177-190): Creates candidates from package links
- `_make_base_candidate_from_link()` (L192-247): Core candidate creation with error handling and caching

**Primary resolution interface:**
- `find_candidates()` (L390-464): Main entry point for finding viable candidates for a requirement
- `collect_root_requirements()` (L519-559): Processes initial requirements and constraints
- `make_requirements_from_spec()` (L566-582): Creates requirement objects from specifiers

### CollectedRootRequirements NamedTuple (L89-92)
Data structure containing processed root requirements, constraints, and user-requested packages.

### Helper Functions

**Candidate iteration and filtering:**
- `_iter_found_candidates()` (L249-344): Iterates through candidates from index and installed packages
- `_iter_explicit_candidates_from_base()` (L346-366): Generates explicit candidates with extras
- `_iter_candidates_from_constraints()` (L368-388): Creates candidates from constraint links

**Requirement processing:**
- `_make_requirements_from_install_req()` (L466-517): Converts InstallRequirement to Requirement objects
- `make_requirement_from_candidate()` (L561-564): Creates ExplicitRequirement from candidate

**Error handling and reporting:**
- `get_installation_error()` (L716-816): Comprehensive error reporting for resolution failures
- `_report_requires_python_error()` (L642-662): Python version conflict reporting
- `_report_single_requirement_conflict()` (L664-714): Single requirement conflict reporting

**Utility methods:**
- `_fail_if_link_is_unsupported_wheel()` (L138-145): Validates wheel compatibility
- `get_wheel_cache_entry()` (L595-612): Wheel cache lookup
- `get_dist_to_uninstall()` (L614-640): Determines uninstallation requirements

## Critical Dependencies

- **ResolveLib integration**: Uses resolvelib.ResolutionImpossible for conflict reporting
- **pip._internal.metadata**: BaseDistribution for installed package representation
- **pip._internal.models**: Link and Wheel for package identification
- **pip._vendor.packaging**: Version, SpecifierSet, requirements parsing
- **Local modules**: Various candidate types, requirement types, and constraint handling

## Architectural Patterns

**Caching Strategy**: Extensive use of dictionaries for caching candidates by Link objects and other identifiers to avoid redundant work during resolution.

**Error Handling**: Graceful degradation when candidates fail to build, with comprehensive error reporting including yanked versions, Python version conflicts, and dependency conflicts.

**Lazy Evaluation**: Uses generators and iterators extensively for memory efficiency during candidate discovery.

**Template Pattern**: Uses "template" InstallRequirement objects as basis for creating multiple related requirements and candidates.

## Critical Invariants

- All candidates are cached to ensure consistent object identity during resolution
- Build failures are remembered to prevent repeated failed attempts
- Extras are handled separately from base requirements for efficient constraint resolution
- Installed packages are only considered if they satisfy current specifiers and aren't force-reinstalled