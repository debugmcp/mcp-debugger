# packages/adapter-rust/vendor/codelldb/darwin-x64/lldb/lib/python3.12/site-packages/pip/_vendor/idna/core.py
@source-hash: 972869a1edafba51
@generated: 2026-02-09T17:59:52Z

## Primary Purpose
Core implementation of IDNA (Internationalized Domain Names in Applications) encoding/decoding following RFC 5891 and UTS46 specifications. Handles conversion between Unicode domain names and ASCII-compatible encoding (ACE) using Punycode.

## Exception Hierarchy (L12-29)
- `IDNAError` (L12): Base exception for all IDNA-related errors
- `IDNABidiError` (L17): Bidirectional text validation failures
- `InvalidCodepoint` (L22): Disallowed/unallocated codepoints
- `InvalidCodepointContext` (L27): Valid codepoints in invalid contexts

## Key Constants & Patterns (L8-10)
- `_virama_combining_class = 9`: Unicode combining class for virama characters
- `_alabel_prefix = b'xn--'`: ASCII-compatible encoding prefix for internationalized labels
- `_unicode_dots_re`: Regex matching various Unicode dot separators for domain parsing

## Core Validation Functions

### Length Validation (L49-58)
- `valid_label_length()` (L49): Enforces 63-byte label limit per RFC requirements
- `valid_string_length()` (L55): Enforces 253/254 character domain limits

### Bidirectional Text Validation (L61-117)
- `check_bidi()` (L61): Implements IDNA bidirectional rules 1-6
  - Detects RTL/LTR context and validates character directionality
  - Enforces proper label start/end characters for RTL labels
  - Prevents mixing Arabic-Indic and Extended Arabic-Indic numerals

### Character Context Validation
- `valid_contextj()` (L139-183): Validates CONTEXTJ codepoints (0x200C ZWNJ, 0x200D ZWJ)
  - Checks virama combining class and Arabic joining type requirements
- `valid_contexto()` (L186-225): Validates CONTEXTO codepoints with script-specific rules
  - Handles middle dot (L·L), Greek lower numeral sign, Hebrew punctuation, etc.

### Label Structure Validation (L120-136)
- `check_initial_combiner()` (L120): Prevents labels starting with combining marks
- `check_hyphen_ok()` (L126): Enforces hyphen position restrictions
- `check_nfc()` (L134): Ensures Unicode normalization form C

## Core Processing Functions

### Label Encoding/Decoding (L255-300)
- `alabel()` (L255): Converts Unicode label to ASCII-compatible encoding
  - Attempts ASCII encoding first, falls back to Punycode with 'xn--' prefix
- `ulabel()` (L274): Converts A-label back to Unicode
  - Handles both A-labels (xn-- prefixed) and regular ASCII labels

### Domain Processing (L335-395)
- `encode()` (L335): Full domain encoding with UTS46 support
  - Splits on Unicode dots, processes each label, validates total length
- `decode()` (L368): Full domain decoding with UTS46 support
  - Reverse of encode operation

### UTS46 Remapping (L303-332)
- `uts46_remap()` (L303): Applies UTS46 character mapping transformations
  - Handles valid (V), mapped (M), disallowed (D), and ignored (I) characters
  - Supports transitional vs non-transitional processing

## Key Dependencies
- `idnadata`: Provides Unicode property tables (scripts, joining types, codepoint classes)
- `intranges`: Efficient integer range containment checking
- `uts46data`: UTS46 character mapping data
- Standard library: `unicodedata`, `bisect`, `re`

## Critical Invariants
- All labels must be ≤63 bytes when encoded
- Domains must be ≤253/254 characters total
- Unicode input must be NFC normalized
- Bidirectional text must follow strict directionality rules
- Context-dependent characters require specific neighboring character validation

## Architectural Patterns
- Exception-driven validation with specific error types for different failure modes
- Layered processing: character → label → domain validation
- Dual-mode operation supporting both strict RFC compliance and UTS46 compatibility
- Lazy loading of mapping data through imports