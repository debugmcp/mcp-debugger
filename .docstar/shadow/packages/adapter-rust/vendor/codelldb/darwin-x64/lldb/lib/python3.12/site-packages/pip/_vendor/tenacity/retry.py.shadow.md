# packages/adapter-rust/vendor/codelldb/darwin-x64/lldb/lib/python3.12/site-packages/pip/_vendor/tenacity/retry.py
@source-hash: 8ebcc3fe6c40e664
@generated: 2026-02-09T18:00:10Z

## Primary Purpose
Defines retry condition strategies for the tenacity library, providing a comprehensive set of classes to determine when operations should be retried based on exceptions, results, or combinations thereof.

## Core Architecture

**Abstract Base:** `retry_base` (L25-37) - ABC defining retry strategy interface with `__call__` method returning boolean retry decision. Implements `__and__`/`__or__` operators for composable retry logic.

**Type Alias:** `RetryBaseT` (L39) - Union type accepting either `retry_base` instances or callable functions matching the retry signature.

## Built-in Strategies

**Always/Never:**
- `retry_never` (L42-49) - Singleton instance always returning False (never retry)
- `retry_always` (L52-59) - Singleton instance always returning True (always retry)

**Exception-Based Strategies:**
- `retry_if_exception` (L62-79) - Base class for exception predicate-based retries
- `retry_if_exception_type` (L81-93) - Retries on specific exception types using isinstance check
- `retry_if_not_exception_type` (L95-107) - Retries except for specific exception types  
- `retry_unless_exception_type` (L109-134) - Retries until specific exception types occur, with inverted logic for successful outcomes
- `retry_if_exception_cause_type` (L136-164) - Recursively checks exception cause chain for matching types
- `retry_if_exception_message` (L198-227) - Retries based on exact message match or regex pattern
- `retry_if_not_exception_message` (L229-253) - Inverted message matching with custom call logic

**Result-Based Strategies:**
- `retry_if_result` (L166-180) - Retries when result satisfies predicate function
- `retry_if_not_result` (L182-196) - Retries when result fails predicate function

**Composite Strategies:**
- `retry_any` (L255-263) - Logical OR combination of multiple retry conditions
- `retry_all` (L265-272) - Logical AND combination of multiple retry conditions

## Key Dependencies
- `abc` - Abstract base class infrastructure
- `re` - Regex pattern matching for message-based retries  
- `typing` - Type hints and TYPE_CHECKING conditional import
- `RetryCallState` - Core state object (imported conditionally)

## Critical Invariants
- All strategies expect `retry_state.outcome` to be set before evaluation
- Exception strategies validate outcome failure state before accessing exceptions
- Result strategies only evaluate predicates on successful outcomes
- Message-based retries require exactly one of `message` or `match` parameters

## Architectural Patterns
- Strategy pattern implementation with composable boolean logic operators
- Template method pattern in exception-based hierarchy
- Predicate-based filtering with lambda function composition
- Recursive exception cause chain traversal for nested error analysis