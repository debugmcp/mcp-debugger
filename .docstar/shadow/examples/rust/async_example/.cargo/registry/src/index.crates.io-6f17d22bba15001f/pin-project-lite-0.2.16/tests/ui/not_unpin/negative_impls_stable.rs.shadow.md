# examples/rust/async_example/.cargo/registry/src/index.crates.io-6f17d22bba15001f/pin-project-lite-0.2.16/tests/ui/not_unpin/negative_impls_stable.rs
@source-hash: f014d5398d505ca5
@generated: 2026-02-09T18:02:38Z

## Purpose
Test file that validates `pin_project_lite` handling of negative `!Unpin` implementations in stable Rust. Specifically tests the interaction between `#[project(!Unpin)]` annotation and manual `Unpin` implementations with complex trait bounds.

## Key Components

### Struct Definitions
- **`Foo<Pinned, Unpinned>` (L5-12)**: Generic struct generated by `pin_project_lite::pin_project!` macro with `#[project(!Unpin)]` attribute. Contains a `#[pin]` field `pinned` and regular field `unpinned`. The `!Unpin` projection means the generated code should not automatically implement `Unpin`.

- **`MyPhantomPinned` (L14)**: Wrapper struct around `core::marker::PhantomPinned` used to create a non-`Unpin` type.

### Trait Implementations
- **`Unpin for MyPhantomPinned` (L15)**: Conditional `Unpin` implementation with impossible bound `for<'cursed> str: Sized` - this bound can never be satisfied, making `MyPhantomPinned` effectively non-`Unpin`.

- **`Unpin for Foo<MyPhantomPinned, ()>` (L16)**: Manual `Unpin` implementation for specific instantiation of `Foo`. This tests whether the macro-generated code properly allows manual `Unpin` implementations when `!Unpin` is specified.

### Test Functions
- **`is_unpin<T: Unpin>()` (L18)**: Utility function that requires `T` to implement `Unpin` trait, used for compile-time verification.

- **`main()` (L20-22)**: Entry point that calls `is_unpin::<Foo<MyPhantomPinned, ()>>()`. This should compile successfully if the manual `Unpin` implementation (L16) is properly recognized despite the `!Unpin` annotation.

## Architecture & Purpose
This is a regression test for pin-project-lite issue #340, ensuring that `#[project(!Unpin)]` doesn't prevent manual `Unpin` implementations from being used. The test validates that the macro generates code compatible with explicit `Unpin` bounds even when negative reasoning is involved.

## Dependencies
- `pin_project_lite` crate for the `pin_project!` macro
- `core::marker::PhantomPinned` for non-`Unpin` marker type