# examples/rust/async_example/.cargo/registry/src/index.crates.io-6f17d22bba15001f/tokio-1.48.0/src/io/util/async_read_ext.rs
@source-hash: 8144159bc923640f
@generated: 2026-02-09T18:02:50Z

**Primary Purpose**
Extension trait providing convenient async read methods for types implementing `AsyncRead`. Acts as the primary interface developers use instead of the base `AsyncRead` trait, similar to how `std::io::Read` has `BufReadExt`.

**Core Architecture**
- **AsyncReadExt trait (L65-1451)**: Main extension trait that must be implemented by all `AsyncRead` types
- **Blanket implementation (L1454)**: Auto-implements `AsyncReadExt` for all `AsyncRead + ?Sized` types
- **read_impl! macro (L21-35)**: Code generator for numeric reader methods, creates wrapper functions that delegate to specialized future types

**Key Method Categories**

**Basic Reading Operations:**
- `chain(next)` (L98-104): Chains two readers sequentially using `Chain<Self, R>`
- `read(&mut [u8])` (L177-182): Core byte reading, returns `Read<'a, Self>` future
- `read_buf(&mut BufMut)` (L258-264): Reads into growable buffer, returns `ReadBuf<'a, Self, B>` 
- `read_exact(&mut [u8])` (L323-328): Ensures exact byte count read, returns `ReadExact<'a, Self>`

**Numeric Reading Methods (L330-1304):**
All generated by `read_impl!` macro, each returns specialized future type:
- Integer readers: `read_u8()`, `read_i8()`, `read_u16()`, `read_i16()`, etc.
- Big-endian variants: `read_u16()`, `read_u32()`, `read_u64()`, `read_u128()`
- Little-endian variants: `read_u16_le()`, `read_u32_le()`, `read_u64_le()`, `read_u128_le()`
- Floating point: `read_f32()`, `read_f64()`, `read_f32_le()`, `read_f64_le()`

**Utility Operations:**
- `read_to_end(&mut Vec<u8>)` (L1354-1359): Reads all data until EOF
- `read_to_string(&mut String)` (L1404-1409): UTF-8 validated read to string
- `take(limit)` (L1445-1450): Creates limited reader using `Take<Self>`

**Dependencies**
- Heavy reliance on `crate::io::util::*` modules for implementation futures
- `bytes::BufMut` for buffer-based reading
- All methods wrapped in `cfg_io_util!` conditional compilation

**Critical Constraints**
- All methods require `Self: Unpin` for async operation
- Cancel safety varies: basic `read` is cancel-safe, `read_exact` is not
- Numeric readers >1 byte are NOT cancel-safe due to partial read possibility
- Error handling delegates to underlying `read_exact` for numeric operations

**Usage Pattern**
Developers import this trait (`use tokio::io::AsyncReadExt`) to access all convenience methods on any `AsyncRead` type, enabling fluent async I/O operations without directly working with futures.